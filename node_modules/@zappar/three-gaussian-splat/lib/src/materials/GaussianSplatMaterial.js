import * as THREE from 'three';
import { fragmentShaderSource, vertexShaderSource } from '../shaders';
const computeFocalLengths = (width, height, fov, aspect, dpr) => {
    const fovRad = THREE.MathUtils.degToRad(fov);
    const fovXRad = 2 * Math.atan(Math.tan(fovRad / 2) * aspect);
    const fy = (dpr * height) / (2 * Math.tan(fovRad / 2));
    const fx = (dpr * width) / (2 * Math.tan(fovXRad / 2));
    return new THREE.Vector2(fx, fy);
};
export class GaussianSplatMaterial extends THREE.RawShaderMaterial {
    set sphereRadius(value) {
        this.uniforms.sphereRadius.value = value;
        this.needsUpdate = true;
    }
    set sphereCenter(value) {
        this.uniforms.sphereCenter.value = value;
        this.needsUpdate = true;
    }
    set minAlpha(value) {
        this.uniforms.minAlpha.value = value;
        this.needsUpdate = true;
    }
    set planeNormal(value) {
        this.uniforms.planeNormal.value = value;
        this.needsUpdate = true;
    }
    set planeDistance(value) {
        this.uniforms.planeDistance.value = value;
        this.needsUpdate = true;
    }
    constructor() {
        const uniforms = {
            viewport: {
                value: new THREE.Vector2(),
            },
            focal: {
                value: new THREE.Vector2(),
            },
            minAlpha: {
                value: 0.02,
            },
            sphereRadius: {
                value: -1,
            },
            sphereCenter: {
                value: new THREE.Vector3(0, 0, 0),
            },
            planeNormal: {
                value: new THREE.Vector3(0, 0, 0),
            },
            planeDistance: {
                value: 0,
            },
        };
        super({
            uniforms: uniforms,
            fragmentShader: fragmentShaderSource,
            vertexShader: vertexShaderSource,
            depthTest: true,
            depthWrite: false,
            transparent: true,
        });
        this.onResize = () => {
            if (!this.currentCamera)
                return;
            const size = new THREE.Vector2();
            this.renderer?.getSize(size);
            const width = size.x;
            const height = size.y;
            const dpr = this.renderer?.getPixelRatio() || 1;
            let fov = 75;
            let aspect = width / height;
            if (this.currentCamera instanceof THREE.PerspectiveCamera) {
                fov = this.currentCamera.fov;
                aspect = this.currentCamera.aspect;
            }
            this.uniforms.focal.value = computeFocalLengths(width, height, fov, aspect, dpr);
            this.uniforms.viewport.value = new THREE.Vector2(width * dpr, height * dpr);
        };
        window.addEventListener('resize', this.onResize);
    }
    dispose() {
        window.removeEventListener('resize', this.onResize);
        return super.dispose();
    }
    initialize(camera, renderer) {
        this.renderer = renderer;
        this.currentCamera = camera;
        const size = new THREE.Vector2();
        renderer.getSize(size);
        const dpr = renderer.getPixelRatio();
        let fov = 75;
        let aspect = size.x / size.y;
        if (this.currentCamera instanceof THREE.PerspectiveCamera) {
            fov = this.currentCamera.fov;
            aspect = this.currentCamera.aspect;
        }
        this.uniforms.focal.value = computeFocalLengths(size.x, size.y, fov, aspect, dpr);
        this.uniforms.viewport.value = new THREE.Vector2(size.x * dpr, size.y * dpr);
    }
}
