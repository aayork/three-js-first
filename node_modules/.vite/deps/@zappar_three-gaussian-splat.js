import {
  BufferAttribute,
  BufferGeometry,
  Float32BufferAttribute,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  LineBasicMaterial,
  LineSegments,
  Loader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  PerspectiveCamera,
  PlaneGeometry,
  RawShaderMaterial,
  SphereGeometry,
  Vector2,
  Vector3
} from "./chunk-BJFHWZFX.js";

// node_modules/@zappar/three-gaussian-splat/lib/src/materials/MaskMaterial.js
var maskMaterial = new MeshBasicMaterial({
  wireframe: true,
  color: 8421504,
  transparent: true,
  opacity: 0.4
});

// node_modules/three/examples/jsm/helpers/VertexNormalsHelper.js
var _v1 = new Vector3();
var _v2 = new Vector3();
var _normalMatrix = new Matrix3();
var VertexNormalsHelper = class extends LineSegments {
  constructor(object, size = 1, color = 16711680) {
    const geometry = new BufferGeometry();
    const nNormals = object.geometry.attributes.normal.count;
    const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
    geometry.setAttribute("position", positions);
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.object = object;
    this.size = size;
    this.type = "VertexNormalsHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update() {
    this.object.updateMatrixWorld(true);
    _normalMatrix.getNormalMatrix(this.object.matrixWorld);
    const matrixWorld = this.object.matrixWorld;
    const position = this.geometry.attributes.position;
    const objGeometry = this.object.geometry;
    if (objGeometry) {
      const objPos = objGeometry.attributes.position;
      const objNorm = objGeometry.attributes.normal;
      let idx = 0;
      for (let j = 0, jl = objPos.count; j < jl; j++) {
        _v1.fromBufferAttribute(objPos, j).applyMatrix4(matrixWorld);
        _v2.fromBufferAttribute(objNorm, j);
        _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);
        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);
        idx = idx + 1;
        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);
        idx = idx + 1;
      }
    }
    position.needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};

// node_modules/@zappar/three-gaussian-splat/lib/src/mesh/MaskingPlane.js
var MaskingPlane = class extends Mesh {
  constructor() {
    super(new PlaneGeometry(10, 10, 4, 4), maskMaterial);
    this._helper = new VertexNormalsHelper(this, 0.3, 8421504);
    this.add(this._helper);
    this._helper.update();
  }
};

// node_modules/@zappar/three-gaussian-splat/lib/src/mesh/MaskingSphere.js
var MaskingSphere = class extends Mesh {
  constructor() {
    super(new SphereGeometry(1, 16, 16), maskMaterial);
  }
};

// node_modules/@zappar/three-gaussian-splat/lib/src/loaders/SplatLoader.js
var SplatLoader = class extends Loader {
  constructor(processDataCallback, manager) {
    super(manager);
    this.processDataCallback = processDataCallback;
  }
  load(url, onLoad, onProgress, onError) {
    fetch(this._getAbsoluteURL(url), {
      mode: "cors",
      credentials: this.withCredentials ? "include" : "omit"
    }).then((req) => {
      if (req.status !== 200) {
        if (onError) {
          onError(this._getErrorEventForNon200Response(req));
        }
        this.manager.itemError(url);
        return;
      }
      return req.arrayBuffer();
    }).then((buffer) => {
      if (!buffer) {
        return;
      }
      const data = new Uint8Array(buffer, 0, this._getRowQuantisedByteLength(buffer.byteLength));
      this._processData(data, data.length, true);
      if (onLoad) {
        onLoad(data);
      }
      this.manager.itemEnd(url);
    }).catch((error) => {
      if (onError) {
        onError(this._getErrorEventForFetchError(error));
      }
      this.manager.itemError(url);
    });
    this.manager.itemStart(url);
  }
  loadAsync(url, onProgress) {
    return new Promise((resolve, reject) => {
      this.load(url, (data) => {
        resolve({ data, bytesRead: data.length });
      }, onProgress, reject);
    });
  }
  stream(url, onLoad, onProgress, onError) {
    return new Promise((resolve) => {
      fetch(this._getAbsoluteURL(url), {
        mode: "cors",
        credentials: this.withCredentials ? "include" : "omit"
      }).then((req) => {
        if (req.status !== 200) {
          if (onError) {
            onError(this._getErrorEventForNon200Response(req));
          }
          this.manager.itemError(url);
          return;
        }
        const { headers, body } = req;
        const contentLength = Number(headers.get("Content-Length"));
        if (!Number.isFinite(contentLength)) {
          if (onError) {
            onError(new ErrorEvent("NetworkError", { message: "Cannot stream response without `Content-Length` header" }));
          }
          this.manager.itemError(url);
          return;
        }
        if (!body) {
          if (onError) {
            onError(new ErrorEvent("NetworkError", { message: "Empty response body" }));
          }
          this.manager.itemError(url);
          return;
        }
        const reader = body.getReader();
        const buffer = new SharedArrayBuffer(contentLength);
        const out = {
          data: new Uint8Array(buffer),
          bytesRead: 0
        };
        const _onProgress = (loaded, total) => {
          if (onProgress) {
            onProgress(new ProgressEvent("progress", { loaded, total }));
          }
        };
        resolve(out);
        _onProgress(0, contentLength);
        let incompleteRowLength = 0;
        const incompleteRow = new Uint8Array(ROW_LENGTH);
        const processStream = ({ done, value: currBytes }) => {
          if (done) {
            if (incompleteRowLength > 0) {
            }
            if (onLoad) {
              onLoad(out.data);
            }
            this.manager.itemEnd(url);
            return;
          }
          if (incompleteRowLength > 0) {
            for (let i = 0; i < incompleteRowLength; i++) {
              out.data[out.bytesRead + i] = incompleteRow[i];
            }
            out.bytesRead += incompleteRowLength;
            incompleteRowLength = 0;
          }
          const currCompleteRowsByteLength = this._getRowQuantisedByteLength(out.bytesRead + currBytes.length) - out.bytesRead;
          const currRemainingByteLength = currBytes.length - currCompleteRowsByteLength;
          if (currRemainingByteLength > 0) {
            for (let i = 0; i < currRemainingByteLength; i++) {
              incompleteRow[i] = currBytes[currCompleteRowsByteLength + i];
            }
            incompleteRow.fill(0, currRemainingByteLength);
            incompleteRowLength = currRemainingByteLength;
          }
          const currRowBytes = currBytes.subarray(0, currCompleteRowsByteLength);
          out.data.set(currRowBytes, out.bytesRead);
          out.bytesRead += currCompleteRowsByteLength;
          this._processData(out.data, out.bytesRead);
          _onProgress(out.bytesRead, contentLength);
          reader.read().then(processStream);
        };
        reader.read().then(processStream);
      }).catch((error) => {
        if (onError) {
          onError(this._getErrorEventForFetchError(error));
        }
        this.manager.itemError(url);
      });
      this.manager.itemStart(url);
    });
  }
  _processData(data, bytesRead, isComplete = false) {
    var _a;
    (_a = this.processDataCallback) == null ? void 0 : _a.call(this, data, bytesRead, isComplete);
  }
  _getAbsoluteURL(url) {
    return this.path + url;
  }
  _getErrorEventForNon200Response(req) {
    return new ErrorEvent("NetworkError", { message: `${req.status} Unable to load ${req.url}` });
  }
  _getErrorEventForFetchError(error) {
    return new ErrorEvent("NetworkError", { message: error.message });
  }
  _getRowQuantisedByteLength(rowLength) {
    return rowLength - rowLength % ROW_LENGTH;
  }
};
var ROW_LENGTH = 3 * 4 + 3 * 4 + 4 + 4;

// node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler] of transferHandlers) {
    if (handler.canHandle(value)) {
      const [serializedValue, transferables] = handler.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    ep.addEventListener("message", function l(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l);
      resolve(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// node_modules/@zappar/three-gaussian-splat/lib/src/geometry/GaussianSplatGeometry.js
var worker = new Worker(new URL("../../cpp-sorter/worker", import.meta.url), { type: "module" });
var SortWorker = wrap(worker);
var GaussianSplatGeometry = class extends InstancedBufferGeometry {
  constructor(maxSplats) {
    super();
    this.maxSplats = maxSplats;
    this.viewProj = [];
    this._sortRunning = false;
    this.loading = false;
    this._initialized = false;
    this.vertexCount = 0;
  }
  async update(camera, meshMatrixWorld) {
    if (this._sortRunning || !this._initialized || !this.worker) {
      return;
    }
    camera.updateMatrixWorld(true);
    this.viewProj = new Matrix4().multiply(camera.projectionMatrix).multiply(camera.matrixWorldInverse).multiply(meshMatrixWorld).elements;
    this._sortRunning = true;
    const viewProj = new Float32Array(this.viewProj);
    const result = await this.worker.runSort(viewProj);
    const { quat, scale, center, color } = this.extractViews(result);
    this.attributes.color.array = color;
    this.attributes.quat.array = quat;
    this.attributes.scale.array = scale;
    this.attributes.center.array = center;
    this.attributes.color.needsUpdate = true;
    this.attributes.quat.needsUpdate = true;
    this.attributes.scale.needsUpdate = true;
    this.attributes.center.needsUpdate = true;
    await Promise.all([
      new Promise((resolve) => this.attributes.color.onUpload(resolve)),
      new Promise((resolve) => this.attributes.quat.onUpload(resolve)),
      new Promise((resolve) => this.attributes.scale.onUpload(resolve)),
      new Promise((resolve) => this.attributes.center.onUpload(resolve))
    ]);
    await this.worker.returnBuffer(transfer(result, [result]));
    this._sortRunning = false;
  }
  async load(url, loadingManager) {
    if (this.loading) {
      console.warn("Geometry is already loading or loaded");
      return;
    }
    this.loading = true;
    try {
      const loader = new SplatLoader(void 0, loadingManager);
      const { data, bytesRead } = await loader.loadAsync(url);
      const vertexCount = Math.floor(bytesRead / ROW_LENGTH2);
      const bufferInfo = trimBuffer(data, this.maxSplats, vertexCount);
      this.worker = await new SortWorker(bufferInfo.vertexCount, transfer(bufferInfo.buffer, [bufferInfo.buffer.buffer]));
      await this.worker.load();
      this.vertexCount = vertexCount;
      this.initAttributes();
    } catch (error) {
      console.error("Error loading geometry:", error);
    }
  }
  async initAttributes() {
    const viewProj = new Float32Array(this.viewProj);
    const result = await this.worker.runSort(viewProj);
    const { quat, scale, center, color } = this.extractViews(result);
    this.setAttribute("color", new InstancedBufferAttribute(color, 4, true));
    this.setAttribute("quat", new InstancedBufferAttribute(quat, 4, true));
    this.setAttribute("scale", new InstancedBufferAttribute(scale, 3, true));
    this.setAttribute("center", new InstancedBufferAttribute(center, 3, true));
    this.setAttribute("position", new BufferAttribute(new Float32Array([1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0]), 3, true));
    this.attributes.position.needsUpdate = true;
    this.setIndex(new BufferAttribute(new Uint16Array([0, 1, 2, 2, 3, 0]), 1, true));
    this.instanceCount = Math.min(quat.length / 4, this.maxSplats);
    this.loading = false;
    this._initialized = true;
  }
  extractViews(receivedBuffer) {
    const combined = new Float32Array(receivedBuffer);
    const quatLength = 4 * this.vertexCount;
    const scaleLength = 3 * this.vertexCount;
    const centerLength = 3 * this.vertexCount;
    const colorLength = 4 * this.vertexCount;
    const quatOffset = 0;
    const scaleOffset = quatOffset + quatLength;
    const centerOffset = scaleOffset + scaleLength;
    const colorOffset = centerOffset + centerLength;
    const quat = combined.subarray(quatOffset, quatOffset + quatLength);
    const scale = combined.subarray(scaleOffset, scaleOffset + scaleLength);
    const center = combined.subarray(centerOffset, centerOffset + centerLength);
    const color = combined.subarray(colorOffset, colorOffset + colorLength);
    return { quat, scale, center, color };
  }
  dispose() {
    var _a;
    (_a = this.worker) == null ? void 0 : _a.dispose();
    return super.dispose();
  }
};
var ROW_LENGTH2 = 3 * 4 + 3 * 4 + 4 + 4;
function trimBuffer(_buffer, _maxSplats, _vertexCount) {
  const actualVertexCount = Math.min(_vertexCount, _maxSplats);
  const actualBufferSize = ROW_LENGTH2 * actualVertexCount;
  const buffer = _buffer.slice(0, actualBufferSize);
  return { buffer, vertexCount: actualVertexCount };
}

// node_modules/@zappar/three-gaussian-splat/lib/src/shaders.js
var vertexShaderSource = `
precision mediump float;

attribute vec3 position;

attribute vec4 color;
attribute vec4 quat;
attribute vec3 scale;
attribute vec3 center;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform vec2 focal;
uniform vec2 viewport;
uniform vec3 sphereCenter;
uniform vec3 planeNormal;
uniform float planeDistance;

varying vec4 vColor;
varying vec3 vConic;
varying vec2 vCenter;
varying vec2 vPosition;
varying float vDistance;
varying float vPlaneSide;




mat3 transpose(mat3 m) { return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]); }

mat3 compute_cov3d(vec3 scale, vec4 rot) {
    mat3 S = mat3(
        scale.x, 0.0, 0.0,
        0.0, scale.y, 0.0,
        0.0, 0.0, scale.z
    );
    mat3 R = mat3(
        1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),
        2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),
        2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z)
    );
    mat3 M = S * R;
    return transpose(M) * M;
}

vec3 compute_cov2d(vec3 center, vec3 scale, vec4 rot){
    mat3 Vrk = compute_cov3d(scale, rot);
    vec4 t = modelViewMatrix * vec4(center, 1.0);
    vec2 lims = 1.3 * 0.5 * viewport / focal;
    t.xy = min(lims, max(-lims, t.xy / t.z)) * t.z;
    mat3 J = mat3(
        focal.x / t.z, 0., -(focal.x * t.x) / (t.z * t.z),
        0., focal.y / t.z, -(focal.y * t.y) / (t.z * t.z),
        0., 0., 0.
    );
    mat3 W = transpose(mat3(modelViewMatrix));
    mat3 T = W * J;
    mat3 cov = transpose(T) * transpose(Vrk) * T;
    return vec3(cov[0][0] + 0.3, cov[0][1], cov[1][1] + 0.3);
}

void main () {
    vDistance = length(center - sphereCenter);
    vPlaneSide = dot(center, planeNormal) + planeDistance;

    vec4 camspace = modelViewMatrix * vec4(center, 1);

    vec4 pos2d = projectionMatrix  * camspace;

    vec3 cov2d = compute_cov2d(center, scale, quat);
    float det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;
    vec3 conic = vec3(cov2d.z, cov2d.y, cov2d.x) / det;
    float mid = 0.5 * (cov2d.x + cov2d.z);
    float lambda1 = mid + sqrt(max(0.1, mid * mid - det));
    float lambda2 = mid - sqrt(max(0.1, mid * mid - det));
    vec2 v1 = 7.0 * sqrt(lambda1) * normalize(vec2(cov2d.y, lambda1 - cov2d.x));
    vec2 v2 = 7.0 * sqrt(lambda2) * normalize(vec2(-(lambda1 - cov2d.x),cov2d.y));

    vColor = color;
    vConic = conic;
    vCenter = vec2(pos2d) / pos2d.w;

    vPosition = vec2(vCenter + position.x * (position.y < 0.0 ? v1 : v2) / viewport);
    gl_Position = vec4(vPosition, pos2d.z / pos2d.w, 1);
}
`;
var fragmentShaderSource = `
precision mediump float;

varying vec4 vColor;
varying vec3 vConic;
varying vec2 vCenter;
varying float vDistance;
varying float vPlaneSide;

uniform vec2 viewport;
uniform vec2 focal;
uniform float minAlpha;
uniform float sphereRadius;

uniform vec3 planeNormal;

void main () {
    // Sphere radius = -1.0 means no sphere masking

    if(vPlaneSide > 0.0) {
        discard;
    }

    if (sphereRadius != -1.0 && (vDistance > sphereRadius)) {
        discard;
    }

	vec2 d = (vCenter - 2.0 * (gl_FragCoord.xy/viewport - vec2(0.5, 0.5))) * viewport * 0.5;

	float power = -0.5 * (vConic.x * d.x * d.x + vConic.z * d.y * d.y) + vConic.y * d.x * d.y;

	if (power > 0.0) discard;
	float alpha = min(0.99, vColor.a * exp(power));
	if(alpha < minAlpha) discard;

    gl_FragColor = vec4(vColor.rgb, alpha);
}
`;

// node_modules/@zappar/three-gaussian-splat/lib/src/materials/GaussianSplatMaterial.js
var computeFocalLengths = (width, height, fov, aspect, dpr) => {
  const fovRad = MathUtils.degToRad(fov);
  const fovXRad = 2 * Math.atan(Math.tan(fovRad / 2) * aspect);
  const fy = dpr * height / (2 * Math.tan(fovRad / 2));
  const fx = dpr * width / (2 * Math.tan(fovXRad / 2));
  return new Vector2(fx, fy);
};
var GaussianSplatMaterial = class extends RawShaderMaterial {
  set sphereRadius(value) {
    this.uniforms.sphereRadius.value = value;
    this.needsUpdate = true;
  }
  set sphereCenter(value) {
    this.uniforms.sphereCenter.value = value;
    this.needsUpdate = true;
  }
  set minAlpha(value) {
    this.uniforms.minAlpha.value = value;
    this.needsUpdate = true;
  }
  set planeNormal(value) {
    this.uniforms.planeNormal.value = value;
    this.needsUpdate = true;
  }
  set planeDistance(value) {
    this.uniforms.planeDistance.value = value;
    this.needsUpdate = true;
  }
  constructor() {
    const uniforms = {
      viewport: {
        value: new Vector2()
      },
      focal: {
        value: new Vector2()
      },
      minAlpha: {
        value: 0.02
      },
      sphereRadius: {
        value: -1
      },
      sphereCenter: {
        value: new Vector3(0, 0, 0)
      },
      planeNormal: {
        value: new Vector3(0, 0, 0)
      },
      planeDistance: {
        value: 0
      }
    };
    super({
      uniforms,
      fragmentShader: fragmentShaderSource,
      vertexShader: vertexShaderSource,
      depthTest: true,
      depthWrite: false,
      transparent: true
    });
    this.onResize = () => {
      var _a, _b;
      if (!this.currentCamera)
        return;
      const size = new Vector2();
      (_a = this.renderer) == null ? void 0 : _a.getSize(size);
      const width = size.x;
      const height = size.y;
      const dpr = ((_b = this.renderer) == null ? void 0 : _b.getPixelRatio()) || 1;
      let fov = 75;
      let aspect = width / height;
      if (this.currentCamera instanceof PerspectiveCamera) {
        fov = this.currentCamera.fov;
        aspect = this.currentCamera.aspect;
      }
      this.uniforms.focal.value = computeFocalLengths(width, height, fov, aspect, dpr);
      this.uniforms.viewport.value = new Vector2(width * dpr, height * dpr);
    };
    window.addEventListener("resize", this.onResize);
  }
  dispose() {
    window.removeEventListener("resize", this.onResize);
    return super.dispose();
  }
  initialize(camera, renderer) {
    this.renderer = renderer;
    this.currentCamera = camera;
    const size = new Vector2();
    renderer.getSize(size);
    const dpr = renderer.getPixelRatio();
    let fov = 75;
    let aspect = size.x / size.y;
    if (this.currentCamera instanceof PerspectiveCamera) {
      fov = this.currentCamera.fov;
      aspect = this.currentCamera.aspect;
    }
    this.uniforms.focal.value = computeFocalLengths(size.x, size.y, fov, aspect, dpr);
    this.uniforms.viewport.value = new Vector2(size.x * dpr, size.y * dpr);
  }
};

// node_modules/@zappar/three-gaussian-splat/lib/src/mesh/GaussianSplatMesh.js
var GaussianSplatMesh = class extends Mesh {
  constructor(url, maxSplats = Infinity) {
    const material = new GaussianSplatMaterial();
    const geometry = new GaussianSplatGeometry(maxSplats);
    super(geometry, material);
    this.url = url;
    this._normal = new Vector3(0, 0, 1);
    this.rotation.x = Math.PI;
  }
  load(loadingManager) {
    return this.geometry.load(this.url, loadingManager);
  }
  update(camera, renderer) {
    if (this.currentCamera !== camera || this.renderer !== renderer) {
      this.material.initialize(camera, renderer);
    }
    this.currentCamera = camera;
    this.renderer = renderer;
    this.updateMatrixWorld(true);
    this.geometry.update(camera, this.matrixWorld);
    if (this._maskMeshSphere) {
      this.material.sphereCenter = this._maskMeshSphere.position;
      this.material.sphereRadius = this._maskMeshSphere.scale.x;
    }
    if (this._maskMeshPlane) {
      this._normal.set(0, 0, 1);
      this._normal.applyQuaternion(this._maskMeshPlane.quaternion);
      const planePoint = this._maskMeshPlane.position;
      const planeDistance = -planePoint.dot(this._normal);
      this.material.planeNormal = this._normal;
      this.material.planeDistance = planeDistance;
    }
  }
  addMaskMesh(object) {
    if (object instanceof MaskingPlane) {
      this._maskMeshPlane = object;
    } else if (object instanceof MaskingSphere) {
      this._maskMeshSphere = object;
    } else {
      throw new Error("Invalid mask mesh");
    }
    return super.add(object);
  }
};
export {
  GaussianSplatMesh,
  MaskingPlane,
  MaskingSphere
};
/*! Bundled license information:

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@zappar_three-gaussian-splat.js.map
