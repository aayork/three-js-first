{
  "version": 3,
  "sources": ["../../@zappar/three-gaussian-splat/lib/src/materials/MaskMaterial.js", "../../three/examples/jsm/helpers/VertexNormalsHelper.js", "../../@zappar/three-gaussian-splat/lib/src/mesh/MaskingPlane.js", "../../@zappar/three-gaussian-splat/lib/src/mesh/MaskingSphere.js", "../../@zappar/three-gaussian-splat/lib/src/loaders/SplatLoader.js", "../../comlink/src/comlink.ts", "../../@zappar/three-gaussian-splat/lib/src/geometry/GaussianSplatGeometry.js", "../../@zappar/three-gaussian-splat/lib/src/shaders.js", "../../@zappar/three-gaussian-splat/lib/src/materials/GaussianSplatMaterial.js", "../../@zappar/three-gaussian-splat/lib/src/mesh/GaussianSplatMesh.js"],
  "sourcesContent": ["import * as THREE from 'three';\nexport const maskMaterial = new THREE.MeshBasicMaterial({\n    wireframe: true,\n    color: 0x808080,\n    transparent: true,\n    opacity: 0.4,\n});\n", "import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tLineSegments,\n\tLineBasicMaterial,\n\tMatrix3,\n\tVector3\n} from 'three';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _normalMatrix = new Matrix3();\n\nclass VertexNormalsHelper extends LineSegments {\n\n\tconstructor( object, size = 1, color = 0xff0000 ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst nNormals = object.geometry.attributes.normal.count;\n\t\tconst positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\n\n\t\tgeometry.setAttribute( 'position', positions );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.size = size;\n\t\tthis.type = 'VertexNormalsHelper';\n\n\t\t//\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\t_normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tconst matrixWorld = this.object.matrixWorld;\n\n\t\tconst position = this.geometry.attributes.position;\n\n\t\t//\n\n\t\tconst objGeometry = this.object.geometry;\n\n\t\tif ( objGeometry ) {\n\n\t\t\tconst objPos = objGeometry.attributes.position;\n\n\t\t\tconst objNorm = objGeometry.attributes.normal;\n\n\t\t\tlet idx = 0;\n\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\n\n\t\t\tfor ( let j = 0, jl = objPos.count; j < jl; j ++ ) {\n\n\t\t\t\t_v1.fromBufferAttribute( objPos, j ).applyMatrix4( matrixWorld );\n\n\t\t\t\t_v2.fromBufferAttribute( objNorm, j );\n\n\t\t\t\t_v2.applyMatrix3( _normalMatrix ).normalize().multiplyScalar( this.size ).add( _v1 );\n\n\t\t\t\tposition.setXYZ( idx, _v1.x, _v1.y, _v1.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tposition.setXYZ( idx, _v2.x, _v2.y, _v2.z );\n\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tposition.needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nexport { VertexNormalsHelper };\n", "import * as THREE from 'three';\nimport { maskMaterial } from '../materials/MaskMaterial';\nimport { VertexNormalsHelper } from 'three/examples/jsm/helpers/VertexNormalsHelper';\nexport class MaskingPlane extends THREE.Mesh {\n    constructor() {\n        super(new THREE.PlaneGeometry(10, 10, 4, 4), maskMaterial);\n        this._helper = new VertexNormalsHelper(this, 0.3, 0x808080);\n        this.add(this._helper);\n        this._helper.update();\n    }\n}\n", "import * as THREE from 'three';\nimport { maskMaterial } from '../materials/MaskMaterial';\nexport class MaskingSphere extends THREE.Mesh {\n    constructor() {\n        super(new THREE.SphereGeometry(1, 16, 16), maskMaterial);\n    }\n}\n", "import * as THREE from 'three';\nexport class SplatLoader extends THREE.Loader {\n  constructor(processDataCallback, manager) {\n    super(manager);\n    this.processDataCallback = processDataCallback;\n  }\n  load(url, onLoad, onProgress, onError) {\n    fetch(this._getAbsoluteURL(url), {\n      mode: 'cors',\n      credentials: this.withCredentials ? 'include' : 'omit',\n    })\n      .then(req => {\n        if (req.status !== 200) {\n          if (onError) {\n            onError(this._getErrorEventForNon200Response(req));\n          }\n          this.manager.itemError(url);\n          return;\n        }\n        return req.arrayBuffer();\n      })\n      .then(buffer => {\n        if (!buffer) {\n          return;\n        }\n        const data = new Uint8Array(buffer, 0, this._getRowQuantisedByteLength(buffer.byteLength));\n        this._processData(data, data.length, true);\n        if (onLoad) {\n          onLoad(data);\n        }\n        this.manager.itemEnd(url);\n      })\n      .catch(error => {\n        if (onError) {\n          onError(this._getErrorEventForFetchError(error));\n        }\n        this.manager.itemError(url);\n      });\n    this.manager.itemStart(url);\n  }\n  loadAsync(url, onProgress) {\n    return new Promise((resolve, reject) => {\n      this.load(url, data => {\n        resolve({ data, bytesRead: data.length });\n      }, onProgress, reject);\n    });\n  }\n\n  stream(url, onLoad, onProgress, onError) {\n    return new Promise(resolve => {\n      fetch(this._getAbsoluteURL(url), {\n        mode: 'cors',\n        credentials: this.withCredentials ? 'include' : 'omit',\n      })\n        .then(req => {\n          if (req.status !== 200) {\n            if (onError) {\n              onError(this._getErrorEventForNon200Response(req));\n            }\n            this.manager.itemError(url);\n            return;\n          }\n\n          const { headers, body } = req;\n\n          const contentLength = Number(headers.get('Content-Length'));\n          if (!Number.isFinite(contentLength)) {\n            if (onError) {\n              onError(new ErrorEvent('NetworkError', { message: 'Cannot stream response without `Content-Length` header' }));\n            }\n            this.manager.itemError(url);\n            return;\n          }\n\n          if (!body) {\n            if (onError) {\n              onError(new ErrorEvent('NetworkError', { message: 'Empty response body' }));\n            }\n            this.manager.itemError(url);\n            return;\n          }\n\n          const reader = body.getReader();\n          const buffer = new SharedArrayBuffer(contentLength);\n          const out = {\n            data: new Uint8Array(buffer),\n            bytesRead: 0,\n          };\n\n          const _onProgress = (loaded, total) => {\n            if (onProgress) {\n              onProgress(new ProgressEvent('progress', { loaded, total }));\n            }\n          };\n\n          resolve(out);\n          _onProgress(0, contentLength);\n\n          let incompleteRowLength = 0;\n          const incompleteRow = new Uint8Array(ROW_LENGTH);\n\n          const processStream = ({ done, value: currBytes }) => {\n            if (done) {\n              if (incompleteRowLength > 0) {\n                // TODO: warn the user about trailing/incomplete data\n              }\n              if (onLoad) {\n                onLoad(out.data);\n              }\n              this.manager.itemEnd(url);\n              return;\n            }\n\n            if (incompleteRowLength > 0) {\n              // write the previous incomplete row to the buffer\n              for (let i = 0; i < incompleteRowLength; i++) {\n                out.data[out.bytesRead + i] = incompleteRow[i];\n              }\n              out.bytesRead += incompleteRowLength;\n              incompleteRowLength = 0;\n              // save a write here by always zeroing out the rest of the row during write\n            }\n\n            // get the length of the complete rows\n            const currCompleteRowsByteLength = this._getRowQuantisedByteLength(out.bytesRead + currBytes.length) - out.bytesRead;\n            const currRemainingByteLength = currBytes.length - currCompleteRowsByteLength;\n\n            if (currRemainingByteLength > 0) {\n              // store the next incomplete row to be written to the next time processStream is called\n              for (let i = 0; i < currRemainingByteLength; i++) {\n                incompleteRow[i] = currBytes[currCompleteRowsByteLength + i];\n              }\n              incompleteRow.fill(0, currRemainingByteLength);\n              incompleteRowLength = currRemainingByteLength;\n            }\n\n            // get view of only the complete rows\n            const currRowBytes = currBytes.subarray(0, currCompleteRowsByteLength);\n\n            // write the complete rows to the buffer\n            out.data.set(currRowBytes, out.bytesRead);\n            out.bytesRead += currCompleteRowsByteLength;\n\n            this._processData(out.data, out.bytesRead);\n            _onProgress(out.bytesRead, contentLength);\n\n            reader.read().then(processStream);\n          };\n          reader.read().then(processStream);\n        })\n        .catch(error => {\n          if (onError) {\n            onError(this._getErrorEventForFetchError(error));\n          }\n          this.manager.itemError(url);\n        });\n\n      this.manager.itemStart(url);\n    });\n  }\n\n  _processData(data, bytesRead, isComplete = false) {\n    this.processDataCallback?.(data, bytesRead, isComplete);\n  }\n\n  _getAbsoluteURL(url) {\n    return this.path + url;\n  }\n\n  _getErrorEventForNon200Response(req) {\n    return new ErrorEvent('NetworkError', { message: `${req.status} Unable to load ${req.url}` });\n  }\n\n  _getErrorEventForFetchError(error) {\n    return new ErrorEvent('NetworkError', { message: error.message });\n  }\n\n  _getRowQuantisedByteLength(rowLength) {\n    return rowLength - (rowLength % ROW_LENGTH);\n  }\n}\n\n// TODO: find a way to share this constant with GaussianSplatGeometry\nconst ROW_LENGTH = 3 * 4 + 3 * 4 + 4 + 4;\n", "/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Endpoint,\n  EventSource,\n  Message,\n  MessageType,\n  PostMessageWithOrigin,\n  WireValue,\n  WireValueType,\n} from \"./protocol\";\nexport type { Endpoint };\n\nexport const proxyMarker = Symbol(\"Comlink.proxy\");\nexport const createEndpoint = Symbol(\"Comlink.endpoint\");\nexport const releaseProxy = Symbol(\"Comlink.releaseProxy\");\nexport const finalizer = Symbol(\"Comlink.finalizer\");\n\nconst throwMarker = Symbol(\"Comlink.thrown\");\n\n/**\n * Interface of values that were marked to be proxied with `comlink.proxy()`.\n * Can also be implemented by classes.\n */\nexport interface ProxyMarked {\n  [proxyMarker]: true;\n}\n\n/**\n * Takes a type and wraps it in a Promise, if it not already is one.\n * This is to avoid `Promise<Promise<T>>`.\n *\n * This is the inverse of `Unpromisify<T>`.\n */\ntype Promisify<T> = T extends Promise<unknown> ? T : Promise<T>;\n/**\n * Takes a type that may be Promise and unwraps the Promise type.\n * If `P` is not a Promise, it returns `P`.\n *\n * This is the inverse of `Promisify<T>`.\n */\ntype Unpromisify<P> = P extends Promise<infer T> ? T : P;\n\n/**\n * Takes the raw type of a remote property and returns the type that is visible to the local thread on the proxy.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions.\n * See https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype RemoteProperty<T> =\n  // If the value is a method, comlink will proxy it automatically.\n  // Objects are only proxied if they are marked to be proxied.\n  // Otherwise, the property is converted to a Promise that resolves the cloned value.\n  T extends Function | ProxyMarked ? Remote<T> : Promisify<T>;\n\n/**\n * Takes the raw type of a property as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This is the inverse of `RemoteProperty<T>`.\n *\n * Note: This needs to be its own type alias, otherwise it will not distribute over unions. See\n * https://www.typescriptlang.org/docs/handbook/advanced-types.html#distributive-conditional-types\n */\ntype LocalProperty<T> = T extends Function | ProxyMarked\n  ? Local<T>\n  : Unpromisify<T>;\n\n/**\n * Proxies `T` if it is a `ProxyMarked`, clones it otherwise (as handled by structured cloning and transfer handlers).\n */\nexport type ProxyOrClone<T> = T extends ProxyMarked ? Remote<T> : T;\n/**\n * Inverse of `ProxyOrClone<T>`.\n */\nexport type UnproxyOrClone<T> = T extends RemoteObject<ProxyMarked>\n  ? Local<T>\n  : T;\n\n/**\n * Takes the raw type of a remote object in the other thread and returns the type as it is visible to the local thread\n * when proxied with `Comlink.proxy()`.\n *\n * This does not handle call signatures, which is handled by the more general `Remote<T>` type.\n *\n * @template T The raw type of a remote object as seen in the other thread.\n */\nexport type RemoteObject<T> = { [P in keyof T]: RemoteProperty<T[P]> };\n/**\n * Takes the type of an object as a remote thread would see it through a proxy (e.g. when passed in as a function\n * argument) and returns the type that the local thread has to supply.\n *\n * This does not handle call signatures, which is handled by the more general `Local<T>` type.\n *\n * This is the inverse of `RemoteObject<T>`.\n *\n * @template T The type of a proxied object.\n */\nexport type LocalObject<T> = { [P in keyof T]: LocalProperty<T[P]> };\n\n/**\n * Additional special comlink methods available on each proxy returned by `Comlink.wrap()`.\n */\nexport interface ProxyMethods {\n  [createEndpoint]: () => Promise<MessagePort>;\n  [releaseProxy]: () => void;\n}\n\n/**\n * Takes the raw type of a remote object, function or class in the other thread and returns the type as it is visible to\n * the local thread from the proxy return value of `Comlink.wrap()` or `Comlink.proxy()`.\n */\nexport type Remote<T> =\n  // Handle properties\n  RemoteObject<T> &\n    // Handle call signature (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: UnproxyOrClone<TArguments[I]> }\n        ) => Promisify<ProxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: UnproxyOrClone<TArguments[I]>;\n            }\n          ): Promisify<Remote<TInstance>>;\n        }\n      : unknown) &\n    // Include additional special comlink methods available on the proxy.\n    ProxyMethods;\n\n/**\n * Expresses that a type can be either a sync or async.\n */\ntype MaybePromise<T> = Promise<T> | T;\n\n/**\n * Takes the raw type of a remote object, function or class as a remote thread would see it through a proxy (e.g. when\n * passed in as a function argument) and returns the type the local thread has to supply.\n *\n * This is the inverse of `Remote<T>`. It takes a `Remote<T>` and returns its original input `T`.\n */\nexport type Local<T> =\n  // Omit the special proxy methods (they don't need to be supplied, comlink adds them)\n  Omit<LocalObject<T>, keyof ProxyMethods> &\n    // Handle call signatures (if present)\n    (T extends (...args: infer TArguments) => infer TReturn\n      ? (\n          ...args: { [I in keyof TArguments]: ProxyOrClone<TArguments[I]> }\n        ) => // The raw function could either be sync or async, but is always proxied automatically\n        MaybePromise<UnproxyOrClone<Unpromisify<TReturn>>>\n      : unknown) &\n    // Handle construct signature (if present)\n    // The return of construct signatures is always proxied (whether marked or not)\n    (T extends { new (...args: infer TArguments): infer TInstance }\n      ? {\n          new (\n            ...args: {\n              [I in keyof TArguments]: ProxyOrClone<TArguments[I]>;\n            }\n          ): // The raw constructor could either be sync or async, but is always proxied automatically\n          MaybePromise<Local<Unpromisify<TInstance>>>;\n        }\n      : unknown);\n\nconst isObject = (val: unknown): val is object =>\n  (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n\n/**\n * Customizes the serialization of certain values as determined by `canHandle()`.\n *\n * @template T The input type being handled by this transfer handler.\n * @template S The serialized type sent over the wire.\n */\nexport interface TransferHandler<T, S> {\n  /**\n   * Gets called for every value to determine whether this transfer handler\n   * should serialize the value, which includes checking that it is of the right\n   * type (but can perform checks beyond that as well).\n   */\n  canHandle(value: unknown): value is T;\n\n  /**\n   * Gets called with the value if `canHandle()` returned `true` to produce a\n   * value that can be sent in a message, consisting of structured-cloneable\n   * values and/or transferrable objects.\n   */\n  serialize(value: T): [S, Transferable[]];\n\n  /**\n   * Gets called to deserialize an incoming value that was serialized in the\n   * other thread with this transfer handler (known through the name it was\n   * registered under).\n   */\n  deserialize(value: S): T;\n}\n\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler: TransferHandler<object, MessagePort> = {\n  canHandle: (val): val is ProxyMarked =>\n    isObject(val) && (val as ProxyMarked)[proxyMarker],\n  serialize(obj) {\n    const { port1, port2 } = new MessageChannel();\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize(port) {\n    port.start();\n    return wrap(port);\n  },\n};\n\ninterface ThrownValue {\n  [throwMarker]: unknown; // just needs to be present\n  value: unknown;\n}\ntype SerializedThrownValue =\n  | { isError: true; value: Error }\n  | { isError: false; value: unknown };\n\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler: TransferHandler<\n  ThrownValue,\n  SerializedThrownValue\n> = {\n  canHandle: (value): value is ThrownValue =>\n    isObject(value) && throwMarker in value,\n  serialize({ value }) {\n    let serialized: SerializedThrownValue;\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack,\n        },\n      };\n    } else {\n      serialized = { isError: false, value };\n    }\n    return [serialized, []];\n  },\n  deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(\n        new Error(serialized.value.message),\n        serialized.value\n      );\n    }\n    throw serialized.value;\n  },\n};\n\n/**\n * Allows customizing the serialization of certain values.\n */\nexport const transferHandlers = new Map<\n  string,\n  TransferHandler<unknown, unknown>\n>([\n  [\"proxy\", proxyTransferHandler],\n  [\"throw\", throwTransferHandler],\n]);\n\nfunction isAllowedOrigin(\n  allowedOrigins: (string | RegExp)[],\n  origin: string\n): boolean {\n  for (const allowedOrigin of allowedOrigins) {\n    if (origin === allowedOrigin || allowedOrigin === \"*\") {\n      return true;\n    }\n    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function expose(\n  obj: any,\n  ep: Endpoint = globalThis as any,\n  allowedOrigins: (string | RegExp)[] = [\"*\"]\n) {\n  ep.addEventListener(\"message\", function callback(ev: MessageEvent) {\n    if (!ev || !ev.data) {\n      return;\n    }\n    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n      return;\n    }\n    const { id, type, path } = {\n      path: [] as string[],\n      ...(ev.data as Message),\n    };\n    const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    let returnValue;\n    try {\n      const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n      const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n      switch (type) {\n        case MessageType.GET:\n          {\n            returnValue = rawValue;\n          }\n          break;\n        case MessageType.SET:\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n        case MessageType.APPLY:\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n        case MessageType.CONSTRUCT:\n          {\n            const value = new rawValue(...argumentList);\n            returnValue = proxy(value);\n          }\n          break;\n        case MessageType.ENDPOINT:\n          {\n            const { port1, port2 } = new MessageChannel();\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n        case MessageType.RELEASE:\n          {\n            returnValue = undefined;\n          }\n          break;\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = { value, [throwMarker]: 0 };\n    }\n    Promise.resolve(returnValue)\n      .catch((value) => {\n        return { value, [throwMarker]: 0 };\n      })\n      .then((returnValue) => {\n        const [wireValue, transferables] = toWireValue(returnValue);\n        ep.postMessage({ ...wireValue, id }, transferables);\n        if (type === MessageType.RELEASE) {\n          // detach and deactive after sending release response above.\n          ep.removeEventListener(\"message\", callback as any);\n          closeEndPoint(ep);\n          if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n            obj[finalizer]();\n          }\n        }\n      })\n      .catch((error) => {\n        // Send Serialization Error To Caller\n        const [wireValue, transferables] = toWireValue({\n          value: new TypeError(\"Unserializable return value\"),\n          [throwMarker]: 0,\n        });\n        ep.postMessage({ ...wireValue, id }, transferables);\n      });\n  } as any);\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint: Endpoint): endpoint is MessagePort {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint: Endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nexport function wrap<T>(ep: Endpoint, target?: any): Remote<T> {\n  return createProxy<T>(ep, [], target) as any;\n}\n\nfunction throwIfProxyReleased(isReleased: boolean) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction releaseEndpoint(ep: Endpoint) {\n  return requestResponseMessage(ep, {\n    type: MessageType.RELEASE,\n  }).then(() => {\n    closeEndPoint(ep);\n  });\n}\n\ninterface FinalizationRegistry<T> {\n  new (cb: (heldValue: T) => void): FinalizationRegistry<T>;\n  register(\n    weakItem: object,\n    heldValue: T,\n    unregisterToken?: object | undefined\n  ): void;\n  unregister(unregisterToken: object): void;\n}\ndeclare var FinalizationRegistry: FinalizationRegistry<Endpoint>;\n\nconst proxyCounter = new WeakMap<Endpoint, number>();\nconst proxyFinalizers =\n  \"FinalizationRegistry\" in globalThis &&\n  new FinalizationRegistry((ep: Endpoint) => {\n    const newCount = (proxyCounter.get(ep) || 0) - 1;\n    proxyCounter.set(ep, newCount);\n    if (newCount === 0) {\n      releaseEndpoint(ep);\n    }\n  });\n\nfunction registerProxy(proxy: object, ep: Endpoint) {\n  const newCount = (proxyCounter.get(ep) || 0) + 1;\n  proxyCounter.set(ep, newCount);\n  if (proxyFinalizers) {\n    proxyFinalizers.register(proxy, ep, proxy);\n  }\n}\n\nfunction unregisterProxy(proxy: object) {\n  if (proxyFinalizers) {\n    proxyFinalizers.unregister(proxy);\n  }\n}\n\nfunction createProxy<T>(\n  ep: Endpoint,\n  path: (string | number | symbol)[] = [],\n  target: object = function () {}\n): Remote<T> {\n  let isProxyReleased = false;\n  const proxy = new Proxy(target, {\n    get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n      if (prop === releaseProxy) {\n        return () => {\n          unregisterProxy(proxy);\n          releaseEndpoint(ep);\n          isProxyReleased = true;\n        };\n      }\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return { then: () => proxy };\n        }\n        const r = requestResponseMessage(ep, {\n          type: MessageType.GET,\n          path: path.map((p) => p.toString()),\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n      return createProxy(ep, [...path, prop]);\n    },\n    set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased);\n      // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n      const [value, transferables] = toWireValue(rawValue);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.SET,\n          path: [...path, prop].map((p) => p.toString()),\n          value,\n        },\n        transferables\n      ).then(fromWireValue) as any;\n    },\n    apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const last = path[path.length - 1];\n      if ((last as any) === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: MessageType.ENDPOINT,\n        }).then(fromWireValue);\n      }\n      // We just pretend that `bind()` didn’t happen.\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.APPLY,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n    construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      const [argumentList, transferables] = processArguments(rawArgumentList);\n      return requestResponseMessage(\n        ep,\n        {\n          type: MessageType.CONSTRUCT,\n          path: path.map((p) => p.toString()),\n          argumentList,\n        },\n        transferables\n      ).then(fromWireValue);\n    },\n  });\n  registerProxy(proxy, ep);\n  return proxy as any;\n}\n\nfunction myFlat<T>(arr: (T | T[])[]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList: any[]): [WireValue[], Transferable[]] {\n  const processed = argumentList.map(toWireValue);\n  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\n\nconst transferCache = new WeakMap<any, Transferable[]>();\nexport function transfer<T>(obj: T, transfers: Transferable[]): T {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nexport function proxy<T extends {}>(obj: T): T & ProxyMarked {\n  return Object.assign(obj, { [proxyMarker]: true }) as any;\n}\n\nexport function windowEndpoint(\n  w: PostMessageWithOrigin,\n  context: EventSource = globalThis,\n  targetOrigin = \"*\"\n): Endpoint {\n  return {\n    postMessage: (msg: any, transferables: Transferable[]) =>\n      w.postMessage(msg, targetOrigin, transferables),\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context),\n  };\n}\n\nfunction toWireValue(value: any): [WireValue, Transferable[]] {\n  for (const [name, handler] of transferHandlers) {\n    if (handler.canHandle(value)) {\n      const [serializedValue, transferables] = handler.serialize(value);\n      return [\n        {\n          type: WireValueType.HANDLER,\n          name,\n          value: serializedValue,\n        },\n        transferables,\n      ];\n    }\n  }\n  return [\n    {\n      type: WireValueType.RAW,\n      value,\n    },\n    transferCache.get(value) || [],\n  ];\n}\n\nfunction fromWireValue(value: WireValue): any {\n  switch (value.type) {\n    case WireValueType.HANDLER:\n      return transferHandlers.get(value.name)!.deserialize(value.value);\n    case WireValueType.RAW:\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(\n  ep: Endpoint,\n  msg: Message,\n  transfers?: Transferable[]\n): Promise<WireValue> {\n  return new Promise((resolve) => {\n    const id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev: MessageEvent) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n      ep.removeEventListener(\"message\", l as any);\n      resolve(ev.data);\n    } as any);\n    if (ep.start) {\n      ep.start();\n    }\n    ep.postMessage({ id, ...msg }, transfers);\n  });\n}\n\nfunction generateUUID(): string {\n  return new Array(4)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n    .join(\"-\");\n}\n", "import * as THREE from 'three';\nimport { SplatLoader } from '../loaders/SplatLoader';\nimport { transfer, wrap } from 'comlink';\nconst worker = new Worker(new URL('../../cpp-sorter/worker', import.meta.url), { type: 'module' });\nconst SortWorker = wrap(worker);\nexport class GaussianSplatGeometry extends THREE.InstancedBufferGeometry {\n    constructor(maxSplats) {\n        super();\n        this.maxSplats = maxSplats;\n        this.viewProj = [];\n        this._sortRunning = false;\n        this.loading = false;\n        this._initialized = false;\n        this.vertexCount = 0;\n    }\n    async update(camera, meshMatrixWorld) {\n        if (this._sortRunning || !this._initialized || !this.worker) {\n            return;\n        }\n        camera.updateMatrixWorld(true);\n        this.viewProj = new THREE.Matrix4().multiply(camera.projectionMatrix).multiply(camera.matrixWorldInverse).multiply(meshMatrixWorld).elements;\n        this._sortRunning = true;\n        const viewProj = new Float32Array(this.viewProj);\n        const result = await this.worker.runSort(viewProj);\n        const { quat, scale, center, color } = this.extractViews(result);\n        this.attributes.color.array = color;\n        this.attributes.quat.array = quat;\n        this.attributes.scale.array = scale;\n        this.attributes.center.array = center;\n        this.attributes.color.needsUpdate = true;\n        this.attributes.quat.needsUpdate = true;\n        this.attributes.scale.needsUpdate = true;\n        this.attributes.center.needsUpdate = true;\n        await Promise.all([\n            new Promise(resolve => this.attributes.color.onUpload(resolve)),\n            new Promise(resolve => this.attributes.quat.onUpload(resolve)),\n            new Promise(resolve => this.attributes.scale.onUpload(resolve)),\n            new Promise(resolve => this.attributes.center.onUpload(resolve)),\n        ]);\n        await this.worker.returnBuffer(transfer(result, [result]));\n        this._sortRunning = false;\n    }\n    async load(url, loadingManager) {\n        if (this.loading) {\n            console.warn('Geometry is already loading or loaded');\n            return;\n        }\n        this.loading = true;\n        try {\n            const loader = new SplatLoader(undefined, loadingManager);\n            const { data, bytesRead } = await loader.loadAsync(url);\n            const vertexCount = Math.floor(bytesRead / ROW_LENGTH);\n            const bufferInfo = trimBuffer(data, this.maxSplats, vertexCount);\n            this.worker = await new SortWorker(bufferInfo.vertexCount, transfer(bufferInfo.buffer, [bufferInfo.buffer.buffer]));\n            await this.worker.load();\n            this.vertexCount = vertexCount;\n            this.initAttributes();\n        }\n        catch (error) {\n            console.error('Error loading geometry:', error);\n        }\n    }\n    async initAttributes() {\n        const viewProj = new Float32Array(this.viewProj);\n        const result = await this.worker.runSort(viewProj);\n        const { quat, scale, center, color } = this.extractViews(result);\n        this.setAttribute('color', new THREE.InstancedBufferAttribute(color, 4, true));\n        this.setAttribute('quat', new THREE.InstancedBufferAttribute(quat, 4, true));\n        this.setAttribute('scale', new THREE.InstancedBufferAttribute(scale, 3, true));\n        this.setAttribute('center', new THREE.InstancedBufferAttribute(center, 3, true));\n        this.setAttribute('position', new THREE.BufferAttribute(new Float32Array([1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 1, 0]), 3, true));\n        this.attributes.position.needsUpdate = true;\n        this.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 3, 0]), 1, true));\n        this.instanceCount = Math.min(quat.length / 4, this.maxSplats);\n        this.loading = false;\n        this._initialized = true;\n    }\n    extractViews(receivedBuffer) {\n        const combined = new Float32Array(receivedBuffer);\n        const quatLength = 4 * this.vertexCount;\n        const scaleLength = 3 * this.vertexCount;\n        const centerLength = 3 * this.vertexCount;\n        const colorLength = 4 * this.vertexCount;\n        const quatOffset = 0;\n        const scaleOffset = quatOffset + quatLength;\n        const centerOffset = scaleOffset + scaleLength;\n        const colorOffset = centerOffset + centerLength;\n        const quat = combined.subarray(quatOffset, quatOffset + quatLength);\n        const scale = combined.subarray(scaleOffset, scaleOffset + scaleLength);\n        const center = combined.subarray(centerOffset, centerOffset + centerLength);\n        const color = combined.subarray(colorOffset, colorOffset + colorLength);\n        return { quat, scale, center, color };\n    }\n    dispose() {\n        this.worker?.dispose();\n        return super.dispose();\n    }\n}\nconst ROW_LENGTH = 3 * 4 + 3 * 4 + 4 + 4;\nfunction trimBuffer(_buffer, _maxSplats, _vertexCount) {\n    const actualVertexCount = Math.min(_vertexCount, _maxSplats);\n    const actualBufferSize = ROW_LENGTH * actualVertexCount;\n    const buffer = _buffer.slice(0, actualBufferSize);\n    return { buffer, vertexCount: actualVertexCount };\n}\n", "// https://github.com/vincent-lecrubier-skydio/react-three-fiber-gaussian-splat\nexport const vertexShaderSource = `\nprecision mediump float;\n\nattribute vec3 position;\n\nattribute vec4 color;\nattribute vec4 quat;\nattribute vec3 scale;\nattribute vec3 center;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec2 focal;\nuniform vec2 viewport;\nuniform vec3 sphereCenter;\nuniform vec3 planeNormal;\nuniform float planeDistance;\n\nvarying vec4 vColor;\nvarying vec3 vConic;\nvarying vec2 vCenter;\nvarying vec2 vPosition;\nvarying float vDistance;\nvarying float vPlaneSide;\n\n\n\n\nmat3 transpose(mat3 m) { return mat3(m[0][0], m[1][0], m[2][0], m[0][1], m[1][1], m[2][1], m[0][2], m[1][2], m[2][2]); }\n\nmat3 compute_cov3d(vec3 scale, vec4 rot) {\n    mat3 S = mat3(\n        scale.x, 0.0, 0.0,\n        0.0, scale.y, 0.0,\n        0.0, 0.0, scale.z\n    );\n    mat3 R = mat3(\n        1.0 - 2.0 * (rot.z * rot.z + rot.w * rot.w), 2.0 * (rot.y * rot.z - rot.x * rot.w), 2.0 * (rot.y * rot.w + rot.x * rot.z),\n        2.0 * (rot.y * rot.z + rot.x * rot.w), 1.0 - 2.0 * (rot.y * rot.y + rot.w * rot.w), 2.0 * (rot.z * rot.w - rot.x * rot.y),\n        2.0 * (rot.y * rot.w - rot.x * rot.z), 2.0 * (rot.z * rot.w + rot.x * rot.y), 1.0 - 2.0 * (rot.y * rot.y + rot.z * rot.z)\n    );\n    mat3 M = S * R;\n    return transpose(M) * M;\n}\n\nvec3 compute_cov2d(vec3 center, vec3 scale, vec4 rot){\n    mat3 Vrk = compute_cov3d(scale, rot);\n    vec4 t = modelViewMatrix * vec4(center, 1.0);\n    vec2 lims = 1.3 * 0.5 * viewport / focal;\n    t.xy = min(lims, max(-lims, t.xy / t.z)) * t.z;\n    mat3 J = mat3(\n        focal.x / t.z, 0., -(focal.x * t.x) / (t.z * t.z),\n        0., focal.y / t.z, -(focal.y * t.y) / (t.z * t.z),\n        0., 0., 0.\n    );\n    mat3 W = transpose(mat3(modelViewMatrix));\n    mat3 T = W * J;\n    mat3 cov = transpose(T) * transpose(Vrk) * T;\n    return vec3(cov[0][0] + 0.3, cov[0][1], cov[1][1] + 0.3);\n}\n\nvoid main () {\n    vDistance = length(center - sphereCenter);\n    vPlaneSide = dot(center, planeNormal) + planeDistance;\n\n    vec4 camspace = modelViewMatrix * vec4(center, 1);\n\n    vec4 pos2d = projectionMatrix  * camspace;\n\n    vec3 cov2d = compute_cov2d(center, scale, quat);\n    float det = cov2d.x * cov2d.z - cov2d.y * cov2d.y;\n    vec3 conic = vec3(cov2d.z, cov2d.y, cov2d.x) / det;\n    float mid = 0.5 * (cov2d.x + cov2d.z);\n    float lambda1 = mid + sqrt(max(0.1, mid * mid - det));\n    float lambda2 = mid - sqrt(max(0.1, mid * mid - det));\n    vec2 v1 = 7.0 * sqrt(lambda1) * normalize(vec2(cov2d.y, lambda1 - cov2d.x));\n    vec2 v2 = 7.0 * sqrt(lambda2) * normalize(vec2(-(lambda1 - cov2d.x),cov2d.y));\n\n    vColor = color;\n    vConic = conic;\n    vCenter = vec2(pos2d) / pos2d.w;\n\n    vPosition = vec2(vCenter + position.x * (position.y < 0.0 ? v1 : v2) / viewport);\n    gl_Position = vec4(vPosition, pos2d.z / pos2d.w, 1);\n}\n`;\nexport const fragmentShaderSource = `\nprecision mediump float;\n\nvarying vec4 vColor;\nvarying vec3 vConic;\nvarying vec2 vCenter;\nvarying float vDistance;\nvarying float vPlaneSide;\n\nuniform vec2 viewport;\nuniform vec2 focal;\nuniform float minAlpha;\nuniform float sphereRadius;\n\nuniform vec3 planeNormal;\n\nvoid main () {\n    // Sphere radius = -1.0 means no sphere masking\n\n    if(vPlaneSide > 0.0) {\n        discard;\n    }\n\n    if (sphereRadius != -1.0 && (vDistance > sphereRadius)) {\n        discard;\n    }\n\n\tvec2 d = (vCenter - 2.0 * (gl_FragCoord.xy/viewport - vec2(0.5, 0.5))) * viewport * 0.5;\n\n\tfloat power = -0.5 * (vConic.x * d.x * d.x + vConic.z * d.y * d.y) + vConic.y * d.x * d.y;\n\n\tif (power > 0.0) discard;\n\tfloat alpha = min(0.99, vColor.a * exp(power));\n\tif(alpha < minAlpha) discard;\n\n    gl_FragColor = vec4(vColor.rgb, alpha);\n}\n`;\n", "import * as THREE from 'three';\nimport { fragmentShaderSource, vertexShaderSource } from '../shaders';\nconst computeFocalLengths = (width, height, fov, aspect, dpr) => {\n    const fovRad = THREE.MathUtils.degToRad(fov);\n    const fovXRad = 2 * Math.atan(Math.tan(fovRad / 2) * aspect);\n    const fy = (dpr * height) / (2 * Math.tan(fovRad / 2));\n    const fx = (dpr * width) / (2 * Math.tan(fovXRad / 2));\n    return new THREE.Vector2(fx, fy);\n};\nexport class GaussianSplatMaterial extends THREE.RawShaderMaterial {\n    set sphereRadius(value) {\n        this.uniforms.sphereRadius.value = value;\n        this.needsUpdate = true;\n    }\n    set sphereCenter(value) {\n        this.uniforms.sphereCenter.value = value;\n        this.needsUpdate = true;\n    }\n    set minAlpha(value) {\n        this.uniforms.minAlpha.value = value;\n        this.needsUpdate = true;\n    }\n    set planeNormal(value) {\n        this.uniforms.planeNormal.value = value;\n        this.needsUpdate = true;\n    }\n    set planeDistance(value) {\n        this.uniforms.planeDistance.value = value;\n        this.needsUpdate = true;\n    }\n    constructor() {\n        const uniforms = {\n            viewport: {\n                value: new THREE.Vector2(),\n            },\n            focal: {\n                value: new THREE.Vector2(),\n            },\n            minAlpha: {\n                value: 0.02,\n            },\n            sphereRadius: {\n                value: -1,\n            },\n            sphereCenter: {\n                value: new THREE.Vector3(0, 0, 0),\n            },\n            planeNormal: {\n                value: new THREE.Vector3(0, 0, 0),\n            },\n            planeDistance: {\n                value: 0,\n            },\n        };\n        super({\n            uniforms: uniforms,\n            fragmentShader: fragmentShaderSource,\n            vertexShader: vertexShaderSource,\n            depthTest: true,\n            depthWrite: false,\n            transparent: true,\n        });\n        this.onResize = () => {\n            if (!this.currentCamera)\n                return;\n            const size = new THREE.Vector2();\n            this.renderer?.getSize(size);\n            const width = size.x;\n            const height = size.y;\n            const dpr = this.renderer?.getPixelRatio() || 1;\n            let fov = 75;\n            let aspect = width / height;\n            if (this.currentCamera instanceof THREE.PerspectiveCamera) {\n                fov = this.currentCamera.fov;\n                aspect = this.currentCamera.aspect;\n            }\n            this.uniforms.focal.value = computeFocalLengths(width, height, fov, aspect, dpr);\n            this.uniforms.viewport.value = new THREE.Vector2(width * dpr, height * dpr);\n        };\n        window.addEventListener('resize', this.onResize);\n    }\n    dispose() {\n        window.removeEventListener('resize', this.onResize);\n        return super.dispose();\n    }\n    initialize(camera, renderer) {\n        this.renderer = renderer;\n        this.currentCamera = camera;\n        const size = new THREE.Vector2();\n        renderer.getSize(size);\n        const dpr = renderer.getPixelRatio();\n        let fov = 75;\n        let aspect = size.x / size.y;\n        if (this.currentCamera instanceof THREE.PerspectiveCamera) {\n            fov = this.currentCamera.fov;\n            aspect = this.currentCamera.aspect;\n        }\n        this.uniforms.focal.value = computeFocalLengths(size.x, size.y, fov, aspect, dpr);\n        this.uniforms.viewport.value = new THREE.Vector2(size.x * dpr, size.y * dpr);\n    }\n}\n", "/* eslint-disable eqeqeq */\n/* eslint-disable node/no-unsupported-features/node-builtins */\nimport { GaussianSplatGeometry } from '../geometry/GaussianSplatGeometry';\nimport * as THREE from 'three';\nimport { GaussianSplatMaterial } from '../materials/GaussianSplatMaterial';\nimport { MaskingSphere } from './MaskingSphere';\nimport { MaskingPlane } from './MaskingPlane';\nexport class GaussianSplatMesh extends THREE.Mesh {\n    constructor(url, maxSplats = Infinity) {\n        const material = new GaussianSplatMaterial();\n        const geometry = new GaussianSplatGeometry(maxSplats);\n        super(geometry, material);\n        this.url = url;\n        this._normal = new THREE.Vector3(0, 0, 1);\n        this.rotation.x = Math.PI;\n    }\n    load(loadingManager) {\n        return this.geometry.load(this.url, loadingManager);\n    }\n    update(camera, renderer) {\n        if (this.currentCamera !== camera || this.renderer !== renderer) {\n            this.material.initialize(camera, renderer);\n        }\n        this.currentCamera = camera;\n        this.renderer = renderer;\n        this.updateMatrixWorld(true);\n        this.geometry.update(camera, this.matrixWorld);\n        if (this._maskMeshSphere) {\n            this.material.sphereCenter = this._maskMeshSphere.position;\n            this.material.sphereRadius = this._maskMeshSphere.scale.x;\n        }\n        if (this._maskMeshPlane) {\n            this._normal.set(0, 0, 1);\n            this._normal.applyQuaternion(this._maskMeshPlane.quaternion);\n            const planePoint = this._maskMeshPlane.position;\n            const planeDistance = -planePoint.dot(this._normal);\n            this.material.planeNormal = this._normal;\n            this.material.planeDistance = planeDistance;\n        }\n    }\n    addMaskMesh(object) {\n        if (object instanceof MaskingPlane) {\n            this._maskMeshPlane = object;\n        }\n        else if (object instanceof MaskingSphere) {\n            this._maskMeshSphere = object;\n        }\n        else {\n            throw new Error('Invalid mask mesh');\n        }\n        return super.add(object);\n    }\n}\n"],
  "mappings": "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",
  "names": ["obj", "returnValue", "proxy", "ROW_LENGTH"]
}
