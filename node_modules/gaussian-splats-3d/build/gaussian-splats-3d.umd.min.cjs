!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["Gaussian Splat 3D"]=e["Gaussian Splat 3D"]||{},e.THREE)}(this,(function(e,t){"use strict";function n(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var o=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,o.get?o:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var o=n(t);const i=new o.Vector3,s=new o.Vector3,r=new o.Vector4,a=new o.Vector4,c=new o.Quaternion,l=new o.Quaternion;let h,p;class u{static PositionComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CompressionLevels={0:{BytesPerPosition:12,BytesPerScale:12,BytesPerColor:4,BytesPerRotation:16,ScaleRange:1},1:{BytesPerPosition:6,BytesPerScale:6,BytesPerColor:4,BytesPerRotation:8,ScaleRange:32767}};static CovarianceSizeFloats=6;static CovarianceSizeBytes=24;static HeaderSizeBytes=1024;constructor(e){this.headerBufferData=new ArrayBuffer(u.HeaderSizeBytes),this.headerArrayUint8=new Uint8Array(this.headerBufferData),this.headerArrayUint32=new Uint32Array(this.headerBufferData),this.headerArrayFloat32=new Float32Array(this.headerBufferData),this.headerArrayUint8.set(new Uint8Array(e,0,u.HeaderSizeBytes)),this.versionMajor=this.headerArrayUint8[0],this.versionMinor=this.headerArrayUint8[1],this.headerExtraK=this.headerArrayUint8[2],this.compressionLevel=this.headerArrayUint8[3],this.splatCount=this.headerArrayUint32[1],this.bucketSize=this.headerArrayUint32[2],this.bucketCount=this.headerArrayUint32[3],this.bucketBlockSize=this.headerArrayFloat32[4],this.halfBucketBlockSize=this.bucketBlockSize/2,this.bytesPerBucket=this.headerArrayUint32[5],this.compressionScaleRange=this.headerArrayUint32[6]||u.CompressionLevels[this.compressionLevel].ScaleRange,this.compressionScaleFactor=this.halfBucketBlockSize/this.compressionScaleRange;const t=e.byteLength-u.HeaderSizeBytes;this.splatBufferData=new ArrayBuffer(t),new Uint8Array(this.splatBufferData).set(new Uint8Array(e,u.HeaderSizeBytes,t)),this.bytesPerPosition=u.CompressionLevels[this.compressionLevel].BytesPerPosition,this.bytesPerScale=u.CompressionLevels[this.compressionLevel].BytesPerScale,this.bytesPerColor=u.CompressionLevels[this.compressionLevel].BytesPerColor,this.bytesPerRotation=u.CompressionLevels[this.compressionLevel].BytesPerRotation,this.bytesPerSplat=this.bytesPerPosition+this.bytesPerScale+this.bytesPerColor+this.bytesPerRotation,h=this.fbf.bind(this),p=this.tbf.bind(this),this.linkBufferArrays()}linkBufferArrays(){let e=0===this.compressionLevel?Float32Array:Uint16Array;this.positionArray=new e(this.splatBufferData,0,this.splatCount*u.PositionComponentCount),this.scaleArray=new e(this.splatBufferData,this.bytesPerPosition*this.splatCount,this.splatCount*u.ScaleComponentCount),this.colorArray=new Uint8Array(this.splatBufferData,(this.bytesPerPosition+this.bytesPerScale)*this.splatCount,this.splatCount*u.ColorComponentCount),this.rotationArray=new e(this.splatBufferData,(this.bytesPerPosition+this.bytesPerScale+this.bytesPerColor)*this.splatCount,this.splatCount*u.RotationComponentCount),this.bucketsBase=this.splatCount*this.bytesPerSplat}fbf(e){return 0===this.compressionLevel?e:o.DataUtils.fromHalfFloat(e)}tbf(e){return 0===this.compressionLevel?e:o.DataUtils.toHalfFloat(e)}getHeaderBufferData(){return this.headerBufferData}getSplatBufferData(){return this.splatBufferData}getPosition(e,t=new o.Vector3){let n=[0,0,0];const i=e*u.PositionComponentCount;if(this.compressionLevel>0){const o=this.compressionScaleFactor,s=this.compressionScaleRange,r=Math.floor(e/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+r*this.bytesPerBucket,3),t.x=(this.positionArray[i]-s)*o+n[0],t.y=(this.positionArray[i+1]-s)*o+n[1],t.z=(this.positionArray[i+2]-s)*o+n[2]}else t.x=this.positionArray[i],t.y=this.positionArray[i+1],t.z=this.positionArray[i+2];return t}setPosition(e,t){let n=[0,0,0];const o=e*u.PositionComponentCount;if(this.compressionLevel>0){const i=1/this.compressionScaleFactor,s=this.compressionScaleRange,r=2*s+1,a=Math.floor(e/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+a*this.bytesPerBucket,3),this.positionArray[o]=clamp(Math.round((t.x-n[0])*i)+s,0,r),this.positionArray[o+1]=clamp(Math.round((t.y-n[1])*i)+s,0,r),this.positionArray[o+2]=clamp(Math.round((t.z-n[2])*i)+s,0,r)}else this.positionArray[o]=t.x,this.positionArray[o+1]=t.y,this.positionArray[o+2]=t.z}getScale(e,t=new o.Vector3){const n=e*u.ScaleComponentCount;return t.set(h(this.scaleArray[n]),h(this.scaleArray[n+1]),h(this.scaleArray[n+2])),t}setScale(e,t){const n=e*u.ScaleComponentCount;this.scaleArray[n]=p(t.x),this.scaleArray[n+1]=p(t.y),this.scaleArray[n+2]=p(t.z)}getRotation(e,t=new o.Quaternion){const n=e*u.RotationComponentCount;return t.set(h(this.rotationArray[n+1]),h(this.rotationArray[n+2]),h(this.rotationArray[n+3]),h(this.rotationArray[n])),t}setRotation(e,t){const n=e*u.RotationComponentCount;this.rotationArray[n]=p(t.w),this.rotationArray[n+1]=p(t.x),this.rotationArray[n+2]=p(t.y),this.rotationArray[n+3]=p(t.z)}getColor(e,t=new o.Vector4){const n=e*u.ColorComponentCount;return t.set(this.colorArray[n],this.colorArray[n+1],this.colorArray[n+2],this.colorArray[n+3]),t}setColor(e,t){const n=e*u.ColorComponentCount;this.colorArray[n]=t.x,this.colorArray[n+1]=t.y,this.colorArray[n+2]=t.z,this.colorArray[n+3]=t.w}getSplatCount(){return this.splatCount}fillCovarianceArray(e){const t=this.splatCount,n=new o.Vector3,i=new o.Quaternion,s=new o.Matrix3,r=new o.Matrix3,a=new o.Matrix3,c=new o.Matrix4;for(let o=0;o<t;o++){const t=o*u.ScaleComponentCount;n.set(h(this.scaleArray[t]),h(this.scaleArray[t+1]),h(this.scaleArray[t+2])),c.makeScale(n.x,n.y,n.z),r.setFromMatrix4(c);const l=o*u.RotationComponentCount;i.set(h(this.rotationArray[l+1]),h(this.rotationArray[l+2]),h(this.rotationArray[l+3]),h(this.rotationArray[l])),c.makeRotationFromQuaternion(i),s.setFromMatrix4(c),a.copy(s).multiply(r);const p=a.elements;e[u.CovarianceSizeFloats*o]=p[0]*p[0]+p[3]*p[3]+p[6]*p[6],e[u.CovarianceSizeFloats*o+1]=p[0]*p[1]+p[3]*p[4]+p[6]*p[7],e[u.CovarianceSizeFloats*o+2]=p[0]*p[2]+p[3]*p[5]+p[6]*p[8],e[u.CovarianceSizeFloats*o+3]=p[1]*p[1]+p[4]*p[4]+p[7]*p[7],e[u.CovarianceSizeFloats*o+4]=p[1]*p[2]+p[4]*p[5]+p[7]*p[8],e[u.CovarianceSizeFloats*o+5]=p[2]*p[2]+p[5]*p[5]+p[8]*p[8]}}fillPositionArray(e){const t=this.splatCount;let n=[0,0,0];for(let o=0;o<t;o++){const t=o*u.PositionComponentCount;if(this.compressionLevel>0){const i=Math.floor(o/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+i*this.bytesPerBucket,3);const s=this.compressionScaleFactor,r=this.compressionScaleRange;e[t]=(this.positionArray[t]-r)*s+n[0],e[t+1]=(this.positionArray[t+1]-r)*s+n[1],e[t+2]=(this.positionArray[t+2]-r)*s+n[2]}else e[t]=this.positionArray[t],e[t+1]=this.positionArray[t+1],e[t+2]=this.positionArray[t+2]}}fillScaleArray(e){const t=this.fbf.bind(this),n=this.splatCount;for(let o=0;o<n;o++){const n=o*u.ScaleComponentCount;e[n]=t(this.scaleArray[n]),e[n+1]=t(this.scaleArray[n+1]),e[n+2]=t(this.scaleArray[n+2])}}fillRotationArray(e){const t=this.fbf.bind(this),n=this.splatCount;for(let o=0;o<n;o++){const n=o*u.RotationComponentCount;e[n]=t(this.rotationArray[n]),e[n+1]=t(this.rotationArray[n+1]),e[n+2]=t(this.rotationArray[n+2]),e[n+3]=t(this.rotationArray[n+3])}}fillColorArray(e){const t=this.splatCount;for(let n=0;n<t;n++){const t=n*u.ColorComponentCount;e[t]=this.colorArray[t],e[t+1]=this.colorArray[t+1],e[t+2]=this.colorArray[t+2],e[t+3]=this.colorArray[t+3]}}swapVertices(e,t){this.getPosition(e,i),this.getPosition(t,s),this.setPosition(t,i),this.setPosition(e,s),this.getScale(e,i),this.getScale(t,s),this.setScale(t,i),this.setScale(e,s),this.getRotation(e,c),this.getRotation(t,l),this.setRotation(t,c),this.setRotation(e,l),this.getColor(e,r),this.getColor(t,a),this.setColor(t,r),this.setColor(e,a)}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const d=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),m=function(e,t){return new Promise(((n,o)=>{fetch(e).then((async e=>{const i=e.body.getReader();let s=0,r=e.headers.get("Content-Length"),a=r?parseInt(r):void 0;const c=[];for(;;)try{const{value:e,done:o}=await i.read();if(o){t&&t(100,"100%",e);const o=new Blob(c).arrayBuffer();n(o);break}let r,l;s+=e.length,void 0!==a&&(r=s/a*100,l=`${r.toFixed(2)}%`),c.push(e),t&&t(r,l,e)}catch(e){o(e);break}}))}))},y=function(e,t,n){return Math.max(Math.min(e,n),t)},f=function(){return performance.now()/1e3},g=256;class w{constructor(e){this.plyBuffer=e}decodeHeader(e){const t=new TextDecoder;let n=0,o="";console.log(".PLY size: "+e.byteLength+" bytes");const i=100;for(;;){if(n+i>=e.byteLength)throw new Error("End of file reached while searching for end of header");const s=new Uint8Array(e,n,i);o+=t.decode(s),n+=i;const r=new Uint8Array(e,Math.max(0,n-200),200);if(t.decode(r).includes("end_header"))break}const s=o.split("\n");let r=0,a={};for(let e=0;e<s.length;e++){const t=s[e].trim();if(t.startsWith("element vertex")){const e=t.match(/\d+/);e&&(r=parseInt(e[0]))}else if(t.startsWith("property")){const e=t.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const t=e[2];a[e[3]]=t}}else if("end_header"===t)break}const c=o.indexOf("end_header")+10+1;return{splatCount:r,propertyTypes:a,vertexData:new DataView(e,c),headerOffset:n}}readRawVertexFast(e,t,n,o,i,s){let r=s||{};for(let s of o){const o=i[s];"float"===o?r[s]=e.getFloat32(t+n[s],!0):"uchar"===o&&(r[s]=e.getUint8(t+n[s])/255)}}parseToSplatBuffer(e=0,t=1){const n=performance.now();console.log("Parsing PLY to SPLAT...");const{splatCount:i,propertyTypes:s,vertexData:r}=this.decodeHeader(this.plyBuffer);let a=0;for(const e in s)e.startsWith("f_rest_")&&(a+=1);const c=a/3;console.log("Detected degree",0,"with ",c,"coefficients per color");const l=[];for(let e=0;e<3;++e)l.push(`f_dc_${e}`);for(let e=0;e<c;++e)for(let t=0;t<3;++t)l.push(`f_rest_${t*c+e}`);let h=0,p={};const d={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let e in s)if(s.hasOwnProperty(e)){const t=s[e];p[e]=h,h+=d[t]}let m={};const f=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"],w=[],C={};for(let e of f)C[e]=0;w.push(C);for(let e=0;e<i;e++){let n;if(this.readRawVertexFast(r,e*h,p,f,s,m),n=s.opacity?1/(1+Math.exp(-m.opacity))*255:255,n>t){const e={};for(let t of f)e[t]=m[t];w.push(e)}}console.log("Total valid splats: ",w.length,"out of",i);const v=[];for(let e=0;e<w.length;e++)m=w[e],v.push([m.x,m.y,m.z]);const x=this.computeBuckets(v),A=x.length*g,b=u.HeaderSizeBytes,M=new Uint8Array(new ArrayBuffer(b));M[3]=e,new Uint32Array(M.buffer,4,1)[0]=A;let P=u.CompressionLevels[e].BytesPerPosition,S=u.CompressionLevels[e].BytesPerScale,D=u.CompressionLevels[e].BytesPerColor,T=u.CompressionLevels[e].BytesPerRotation;const E=new ArrayBuffer(P*A),B=new ArrayBuffer(S*A),z=new ArrayBuffer(D*A),F=new ArrayBuffer(T*A),V=u.CompressionLevels[e].ScaleRange,L=V/2.5,R=2*V+1,I=new o.Vector3,k=new o.Vector3;let U=0;for(let t=0;t<x.length;t++){const n=x[t];I.fromArray(n.center);for(let t=0;t<n.splats.length;t++){let i=n.splats[t],r=!1;if(0===i&&(r=!0),m=w[i],0===e){const e=new Float32Array(E,U*P,3),t=new Float32Array(B,U*S,3),n=new Float32Array(F,U*T,4);if(s.scale_0){const e=new o.Quaternion(m.rot_1,m.rot_2,m.rot_3,m.rot_0);e.normalize(),n.set([e.w,e.x,e.y,e.z]),t.set([Math.exp(m.scale_0),Math.exp(m.scale_1),Math.exp(m.scale_2)])}else t.set([.01,.01,.01]),n.set([1,0,0,0]);e.set([m.x,m.y,m.z])}else{const e=new Uint16Array(E,U*P,3),t=new Uint16Array(B,U*S,3),n=new Uint16Array(F,U*T,4),i=o.DataUtils.toHalfFloat.bind(o.DataUtils);if(s.scale_0){const e=new o.Quaternion(m.rot_1,m.rot_2,m.rot_3,m.rot_0);e.normalize(),n.set([i(e.w),i(e.x),i(e.y),i(e.z)]),t.set([i(Math.exp(m.scale_0)),i(Math.exp(m.scale_1)),i(Math.exp(m.scale_2))])}else t.set([i(.01),i(.01),i(.01)]),n.set([i(1),0,0,0]);k.set(m.x,m.y,m.z).sub(I),k.x=Math.round(k.x*L)+V,k.x=y(k.x,0,R),k.y=Math.round(k.y*L)+V,k.y=y(k.y,0,R),k.z=Math.round(k.z*L)+V,k.z=y(k.z,0,R),e.set([k.x,k.y,k.z])}const a=new Uint8ClampedArray(z,U*D,4);if(r)a[0]=255,a[1]=0,a[2]=0,a[3]=0;else{if(s.f_dc_0){const e=.28209479177387814;a.set([255*(.5+e*m.f_dc_0),255*(.5+e*m.f_dc_1),255*(.5+e*m.f_dc_2)])}else a.set([255,0,0]);s.opacity?a[3]=1/(1+Math.exp(-m.opacity))*255:a[3]=255}U++}}const O=12*x.length,_=E.byteLength+B.byteLength+z.byteLength+F.byteLength,N=new Uint32Array(M.buffer),j=new Float32Array(M.buffer);let H=b+_;e>0&&(H+=O,N[2]=g,N[3]=x.length,j[4]=5,N[5]=12,N[6]=u.CompressionLevels[e].ScaleRange);const W=new ArrayBuffer(H);if(new Uint8Array(W,0,b).set(M),new Uint8Array(W,b,E.byteLength).set(new Uint8Array(E)),new Uint8Array(W,b+E.byteLength,B.byteLength).set(new Uint8Array(B)),new Uint8Array(W,b+E.byteLength+B.byteLength,z.byteLength).set(new Uint8Array(z)),new Uint8Array(W,b+E.byteLength+B.byteLength+z.byteLength,F.byteLength).set(new Uint8Array(F)),e>0){const e=new Float32Array(W,b+_,3*x.length);for(let t=0;t<x.length;t++){const n=x[t],o=3*t;e[o]=n.center[0],e[o+1]=n.center[1],e[o+2]=n.center[2]}}const G=new u(W),Y=performance.now();return console.log("Parsing PLY to SPLAT complete!"),console.log("Total time: ",(Y-n).toFixed(2)+" ms"),G}computeBuckets(e){const t=e.length,n=new o.Vector3,i=new o.Vector3;for(let o=1;o<t;o++){const t=e[o];(0===o||t[0]<n.x)&&(n.x=t[0]),(0===o||t[0]>i.x)&&(i.x=t[0]),(0===o||t[1]<n.y)&&(n.y=t[1]),(0===o||t[1]>i.y)&&(i.y=t[1]),(0===o||t[2]<n.z)&&(n.z=t[2]),(0===o||t[2]>i.z)&&(i.z=t[2])}const s=(new o.Vector3).copy(i).sub(n),r=Math.ceil(s.y/5),a=Math.ceil(s.z/5),c=new o.Vector3,l=[],h={};for(let o=1;o<t;o++){const t=e[o],i=Math.ceil((t[0]-n.x)/5),s=Math.ceil((t[1]-n.y)/5),p=Math.ceil((t[2]-n.z)/5);c.x=5*(i-1)+n.x+2.5,c.y=5*(s-1)+n.y+2.5,c.z=5*(p-1)+n.z+2.5;const u=i*(r*a)+s*a+p;let d=h[u];d||(h[u]=d={splats:[],center:c.toArray()}),d.splats.push(o),d.splats.length>=g&&(l.push(d),h[u]=null)}for(let e in h)if(h.hasOwnProperty(e)){const t=h[e];if(t){for(;t.splats.length<g;)t.splats.push(0);l.push(t)}}return l}}class C{constructor(){this.splatBuffer=null}fetchFile(e,t){return new Promise(((n,o)=>{m(e,t).then((e=>{n(e)})).catch((e=>{o(e)}))}))}loadFromURL(e,t=0,n=1){return new Promise(((o,i)=>{this.fetchFile(e).then((e=>{const i=new w(e).parseToSplatBuffer(t,n);this.splatBuffer=i,o(i)})).catch((e=>{i(e)}))}))}}class v{constructor(e=null){this.splatBuffer=e,this.downLoadLink=null}loadFromURL(e,t){return new Promise(((n,o)=>{m(e,t).then((e=>{const t=new u(e);n(t)})).catch((e=>{o(e)}))}))}setFromBuffer(e){this.splatBuffer=e}downloadFile(e){const t=new Uint8Array(this.splatBuffer.getHeaderBufferData()),n=new Uint8Array(this.splatBuffer.getSplatBufferData()),o=new Blob([t.buffer,n.buffer],{type:"application/octet-stream"});this.downLoadLink||(this.downLoadLink=document.createElement("a"),document.body.appendChild(this.downLoadLink)),this.downLoadLink.download=e,this.downLoadLink.href=URL.createObjectURL(o),this.downLoadLink.click()}}const x={type:"change"},A={type:"start"},b={type:"end"},M=new t.Ray,P=new t.Plane,S=Math.cos(70*t.MathUtils.DEG2RAD);class D extends t.EventDispatcher{constructor(e,n){super(),this.object=e,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new t.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:t.MOUSE.ROTATE,MIDDLE:t.MOUSE.DOLLY,RIGHT:t.MOUSE.PAN},this.touches={ONE:t.TOUCH.ROTATE,TWO:t.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",J),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",J),this._domElementKeyEvents=null},this.saveState=function(){o.target0.copy(o.target),o.position0.copy(o.object.position),o.zoom0=o.object.zoom},this.reset=function(){o.target.copy(o.target0),o.object.position.copy(o.position0),o.object.zoom=o.zoom0,o.object.updateProjectionMatrix(),o.dispatchEvent(x),o.update(),s=i.NONE},this.update=function(){const n=new t.Vector3,p=(new t.Quaternion).setFromUnitVectors(e.up,new t.Vector3(0,1,0)),u=p.clone().invert(),d=new t.Vector3,m=new t.Quaternion,y=new t.Vector3,f=2*Math.PI;return function(){p.setFromUnitVectors(e.up,new t.Vector3(0,1,0)),u.copy(p).invert();const g=o.object.position;n.copy(g).sub(o.target),n.applyQuaternion(p),a.setFromVector3(n),o.autoRotate&&s===i.NONE&&F(2*Math.PI/60/60*o.autoRotateSpeed),o.enableDamping?(a.theta+=c.theta*o.dampingFactor,a.phi+=c.phi*o.dampingFactor):(a.theta+=c.theta,a.phi+=c.phi);let w=o.minAzimuthAngle,C=o.maxAzimuthAngle;isFinite(w)&&isFinite(C)&&(w<-Math.PI?w+=f:w>Math.PI&&(w-=f),C<-Math.PI?C+=f:C>Math.PI&&(C-=f),a.theta=w<=C?Math.max(w,Math.min(C,a.theta)):a.theta>(w+C)/2?Math.max(w,a.theta):Math.min(C,a.theta)),a.phi=Math.max(o.minPolarAngle,Math.min(o.maxPolarAngle,a.phi)),a.makeSafe(),!0===o.enableDamping?o.target.addScaledVector(h,o.dampingFactor):o.target.add(h),o.zoomToCursor&&T||o.object.isOrthographicCamera?a.radius=_(a.radius):a.radius=_(a.radius*l),n.setFromSpherical(a),n.applyQuaternion(u),g.copy(o.target).add(n),o.object.lookAt(o.target),!0===o.enableDamping?(c.theta*=1-o.dampingFactor,c.phi*=1-o.dampingFactor,h.multiplyScalar(1-o.dampingFactor)):(c.set(0,0,0),h.set(0,0,0));let A=!1;if(o.zoomToCursor&&T){let i=null;if(o.object.isPerspectiveCamera){const e=n.length();i=_(e*l);const t=e-i;o.object.position.addScaledVector(v,t),o.object.updateMatrixWorld()}else if(o.object.isOrthographicCamera){const e=new t.Vector3(D.x,D.y,0);e.unproject(o.object),o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom/l)),o.object.updateProjectionMatrix(),A=!0;const s=new t.Vector3(D.x,D.y,0);s.unproject(o.object),o.object.position.sub(s).add(e),o.object.updateMatrixWorld(),i=n.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),o.zoomToCursor=!1;null!==i&&(this.screenSpacePanning?o.target.set(0,0,-1).transformDirection(o.object.matrix).multiplyScalar(i).add(o.object.position):(M.origin.copy(o.object.position),M.direction.set(0,0,-1).transformDirection(o.object.matrix),Math.abs(o.object.up.dot(M.direction))<S?e.lookAt(o.target):(P.setFromNormalAndCoplanarPoint(o.object.up,o.target),M.intersectPlane(P,o.target))))}else o.object.isOrthographicCamera&&(o.object.zoom=Math.max(o.minZoom,Math.min(o.maxZoom,o.object.zoom/l)),o.object.updateProjectionMatrix(),A=!0);return l=1,T=!1,!!(A||d.distanceToSquared(o.object.position)>r||8*(1-m.dot(o.object.quaternion))>r||y.distanceToSquared(o.target)>0)&&(o.dispatchEvent(x),d.copy(o.object.position),m.copy(o.object.quaternion),y.copy(o.target),A=!1,!0)}}(),this.dispose=function(){o.domElement.removeEventListener("contextmenu",ee),o.domElement.removeEventListener("pointerdown",X),o.domElement.removeEventListener("pointercancel",$),o.domElement.removeEventListener("wheel",Z),o.domElement.removeEventListener("pointermove",q),o.domElement.removeEventListener("pointerup",$),null!==o._domElementKeyEvents&&(o._domElementKeyEvents.removeEventListener("keydown",J),o._domElementKeyEvents=null)};const o=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const r=1e-6,a=new t.Spherical,c=new t.Spherical;let l=1;const h=new t.Vector3,p=new t.Vector2,u=new t.Vector2,d=new t.Vector2,m=new t.Vector2,y=new t.Vector2,f=new t.Vector2,g=new t.Vector2,w=new t.Vector2,C=new t.Vector2,v=new t.Vector3,D=new t.Vector2;let T=!1;const E=[],B={};function z(){return Math.pow(.95,o.zoomSpeed)}function F(e){c.theta-=e}function V(e){c.phi-=e}const L=function(){const e=new t.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),h.add(e)}}(),R=function(){const e=new t.Vector3;return function(t,n){!0===o.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(o.object.up,e)),e.multiplyScalar(t),h.add(e)}}(),I=function(){const e=new t.Vector3;return function(t,n){const i=o.domElement;if(o.object.isPerspectiveCamera){const s=o.object.position;e.copy(s).sub(o.target);let r=e.length();r*=Math.tan(o.object.fov/2*Math.PI/180),L(2*t*r/i.clientHeight,o.object.matrix),R(2*n*r/i.clientHeight,o.object.matrix)}else o.object.isOrthographicCamera?(L(t*(o.object.right-o.object.left)/o.object.zoom/i.clientWidth,o.object.matrix),R(n*(o.object.top-o.object.bottom)/o.object.zoom/i.clientHeight,o.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),o.enablePan=!1)}}();function k(e){o.object.isPerspectiveCamera||o.object.isOrthographicCamera?l/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function U(e){o.object.isPerspectiveCamera||o.object.isOrthographicCamera?l*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),o.enableZoom=!1)}function O(t){if(!o.zoomToCursor)return;T=!0;const n=o.domElement.getBoundingClientRect(),i=t.clientX-n.left,s=t.clientY-n.top,r=n.width,a=n.height;D.x=i/r*2-1,D.y=-s/a*2+1,v.set(D.x,D.y,1).unproject(e).sub(e.position).normalize()}function _(e){return Math.max(o.minDistance,Math.min(o.maxDistance,e))}function N(e){p.set(e.clientX,e.clientY)}function j(e){m.set(e.clientX,e.clientY)}function H(){if(1===E.length)p.set(E[0].pageX,E[0].pageY);else{const e=.5*(E[0].pageX+E[1].pageX),t=.5*(E[0].pageY+E[1].pageY);p.set(e,t)}}function W(){if(1===E.length)m.set(E[0].pageX,E[0].pageY);else{const e=.5*(E[0].pageX+E[1].pageX),t=.5*(E[0].pageY+E[1].pageY);m.set(e,t)}}function G(){const e=E[0].pageX-E[1].pageX,t=E[0].pageY-E[1].pageY,n=Math.sqrt(e*e+t*t);g.set(0,n)}function Y(e){if(1==E.length)u.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);u.set(n,o)}d.subVectors(u,p).multiplyScalar(o.rotateSpeed);const t=o.domElement;F(2*Math.PI*d.x/t.clientHeight),V(2*Math.PI*d.y/t.clientHeight),p.copy(u)}function Q(e){if(1===E.length)y.set(e.pageX,e.pageY);else{const t=ne(e),n=.5*(e.pageX+t.x),o=.5*(e.pageY+t.y);y.set(n,o)}f.subVectors(y,m).multiplyScalar(o.panSpeed),I(f.x,f.y),m.copy(y)}function K(e){const t=ne(e),n=e.pageX-t.x,i=e.pageY-t.y,s=Math.sqrt(n*n+i*i);w.set(0,s),C.set(0,Math.pow(w.y/g.y,o.zoomSpeed)),k(C.y),g.copy(w)}function X(e){!1!==o.enabled&&(0===E.length&&(o.domElement.setPointerCapture(e.pointerId),o.domElement.addEventListener("pointermove",q),o.domElement.addEventListener("pointerup",$)),function(e){E.push(e)}(e),"touch"===e.pointerType?function(e){switch(te(e),E.length){case 1:switch(o.touches.ONE){case t.TOUCH.ROTATE:if(!1===o.enableRotate)return;H(),s=i.TOUCH_ROTATE;break;case t.TOUCH.PAN:if(!1===o.enablePan)return;W(),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(o.touches.TWO){case t.TOUCH.DOLLY_PAN:if(!1===o.enableZoom&&!1===o.enablePan)return;o.enableZoom&&G(),o.enablePan&&W(),s=i.TOUCH_DOLLY_PAN;break;case t.TOUCH.DOLLY_ROTATE:if(!1===o.enableZoom&&!1===o.enableRotate)return;o.enableZoom&&G(),o.enableRotate&&H(),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&o.dispatchEvent(A)}(e):function(e){let n;switch(e.button){case 0:n=o.mouseButtons.LEFT;break;case 1:n=o.mouseButtons.MIDDLE;break;case 2:n=o.mouseButtons.RIGHT;break;default:n=-1}switch(n){case t.MOUSE.DOLLY:if(!1===o.enableZoom)return;!function(e){O(e),g.set(e.clientX,e.clientY)}(e),s=i.DOLLY;break;case t.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===o.enablePan)return;j(e),s=i.PAN}else{if(!1===o.enableRotate)return;N(e),s=i.ROTATE}break;case t.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===o.enableRotate)return;N(e),s=i.ROTATE}else{if(!1===o.enablePan)return;j(e),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&o.dispatchEvent(A)}(e))}function q(e){!1!==o.enabled&&("touch"===e.pointerType?function(e){switch(te(e),s){case i.TOUCH_ROTATE:if(!1===o.enableRotate)return;Y(e),o.update();break;case i.TOUCH_PAN:if(!1===o.enablePan)return;Q(e),o.update();break;case i.TOUCH_DOLLY_PAN:if(!1===o.enableZoom&&!1===o.enablePan)return;!function(e){o.enableZoom&&K(e),o.enablePan&&Q(e)}(e),o.update();break;case i.TOUCH_DOLLY_ROTATE:if(!1===o.enableZoom&&!1===o.enableRotate)return;!function(e){o.enableZoom&&K(e),o.enableRotate&&Y(e)}(e),o.update();break;default:s=i.NONE}}(e):function(e){switch(s){case i.ROTATE:if(!1===o.enableRotate)return;!function(e){u.set(e.clientX,e.clientY),d.subVectors(u,p).multiplyScalar(o.rotateSpeed);const t=o.domElement;F(2*Math.PI*d.x/t.clientHeight),V(2*Math.PI*d.y/t.clientHeight),p.copy(u),o.update()}(e);break;case i.DOLLY:if(!1===o.enableZoom)return;!function(e){w.set(e.clientX,e.clientY),C.subVectors(w,g),C.y>0?k(z()):C.y<0&&U(z()),g.copy(w),o.update()}(e);break;case i.PAN:if(!1===o.enablePan)return;!function(e){y.set(e.clientX,e.clientY),f.subVectors(y,m).multiplyScalar(o.panSpeed),I(f.x,f.y),m.copy(y),o.update()}(e)}}(e))}function $(e){!function(e){delete B[e.pointerId];for(let t=0;t<E.length;t++)if(E[t].pointerId==e.pointerId)return void E.splice(t,1)}(e),0===E.length&&(o.domElement.releasePointerCapture(e.pointerId),o.domElement.removeEventListener("pointermove",q),o.domElement.removeEventListener("pointerup",$)),o.dispatchEvent(b),s=i.NONE}function Z(e){!1!==o.enabled&&!1!==o.enableZoom&&s===i.NONE&&(e.preventDefault(),o.dispatchEvent(A),function(e){O(e),e.deltaY<0?U(z()):e.deltaY>0&&k(z()),o.update()}(e),o.dispatchEvent(b))}function J(e){!1!==o.enabled&&!1!==o.enablePan&&function(e){let t=!1;switch(e.code){case o.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?V(2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):I(0,o.keyPanSpeed),t=!0;break;case o.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?V(-2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):I(0,-o.keyPanSpeed),t=!0;break;case o.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?F(2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):I(o.keyPanSpeed,0),t=!0;break;case o.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?F(-2*Math.PI*o.rotateSpeed/o.domElement.clientHeight):I(-o.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),o.update())}(e)}function ee(e){!1!==o.enabled&&e.preventDefault()}function te(e){let n=B[e.pointerId];void 0===n&&(n=new t.Vector2,B[e.pointerId]=n),n.set(e.pageX,e.pageY)}function ne(e){const t=e.pointerId===E[0].pointerId?E[1]:E[0];return B[t.pointerId]}o.domElement.addEventListener("contextmenu",ee),o.domElement.addEventListener("pointerdown",X),o.domElement.addEventListener("pointercancel",$),o.domElement.addEventListener("wheel",Z,{passive:!1}),this.update()}listenToKeyEvents(e){e.addEventListener("keydown",onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){this._domElementKeyEvents.removeEventListener("keydown",onKeyDown),this._domElementKeyEvents=null}}class T{constructor(e,t){this.message=e||"Loading...",this.container=t||document.body,this.spinnerDivContainer=document.createElement("div"),this.spinnerDiv=document.createElement("div"),this.messageDiv=document.createElement("div"),this.spinnerDivContainer.className="loaderContainer",this.spinnerDiv.className="loader",this.spinnerDivContainer.style.display="none",this.messageDiv.className="message",this.messageDiv.innerHTML=this.message,this.spinnerDivContainer.appendChild(this.spinnerDiv),this.spinnerDivContainer.appendChild(this.messageDiv),this.container.appendChild(this.spinnerDivContainer);const n=document.createElement("style");n.innerHTML="\n\n            .message {\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                padding-top:15px;\n                width: 180px;\n            }\n\n            .loaderContainer {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n            }\n\n            .loader {\n                width: 120px;        /* the size */\n                padding: 15px;       /* the border thickness */\n                background: #07e8d6; /* the color */\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n                margin-left: 30px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        ",this.spinnerDivContainer.appendChild(n)}show(){this.spinnerDivContainer.style.display="block"}hide(){this.spinnerDivContainer.style.display="none"}setMessage(e){this.messageDiv.innerHTML=e}}class E extends o.Object3D{constructor(e=new o.Vector3(0,0,1),t=new o.Vector3(0,0,0),n=1,i=.1,s=16776960,r=.2*n,a=.2*r){super(),this.type="ArrowHelper";const c=new o.CylinderGeometry(i,i,n,32);c.translate(0,n/2,0);const l=new o.CylinderGeometry(0,a,r,32);l.translate(0,n,0),this.position.copy(t),this.line=new o.Mesh(c,new o.MeshBasicMaterial({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new o.Mesh(l,new o.MeshBasicMaterial({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class B{constructor(e){this.scene=e,this.splatRenderTarget=null,this.renderTargetCopyMaterial=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null}updateSplatRenderTargetForRenderDimensions(e,t){this.splatRenderTarget=new o.WebGLRenderTarget(e,t,{format:o.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new o.DepthTexture(e,t),this.splatRenderTarget.depthTexture.format=o.DepthFormat,this.splatRenderTarget.depthTexture.type=o.UnsignedIntType}setupRenderTargetCopyObjects(){this.renderTargetCopyMaterial=new o.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:o.CustomBlending,blendSrc:o.SrcAlphaFactor,blendSrcAlpha:o.SrcAlphaFactor,blendDst:o.OneMinusSrcAlphaFactor,blendDstAlpha:o.OneMinusSrcAlphaFactor}),this.renderTargetCopyMaterial.extensions.fragDepth=!0,this.renderTargetCopyQuad=new o.Mesh(new o.PlaneGeometry(2,2),this.renderTargetCopyMaterial),this.renderTargetCopyCamera=new o.OrthographicCamera(-1,1,1,-1,0,1)}setupMeshCursor(){if(!this.meshCursor){const e=new o.ConeGeometry(.5,1.5,32),t=new o.MeshBasicMaterial({color:16777215}),n=new o.Mesh(e,t);n.rotation.set(0,0,Math.PI),n.position.set(0,1,0);const i=new o.Mesh(e,t);i.position.set(0,-1,0);const s=new o.Mesh(e,t);s.rotation.set(0,0,Math.PI/2),s.position.set(1,0,0);const r=new o.Mesh(e,t);r.rotation.set(0,0,-Math.PI/2),r.position.set(-1,0,0),this.meshCursor=new o.Object3D,this.meshCursor.add(n),this.meshCursor.add(i),this.meshCursor.add(s),this.meshCursor.add(r),this.meshCursor.scale.set(.1,.1,.1),this.scene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(this.meshCursor.children.forEach((e=>{e.geometry.dispose(),e.material.dispose()})),this.scene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const e=new o.SphereGeometry(.5,32,32),t=B.buildFocusMarkerMaterial();t.depthTest=!1,t.depthWrite=!1,t.transparent=!0;const n=new o.Mesh(e,t);this.focusMarker=n}}updateFocusMarker=function(){const e=new o.Vector3,t=new o.Matrix4;return function(n,o,i){t.copy(o.matrixWorld).invert(),e.copy(n).applyMatrix4(t),e.normalize().multiplyScalar(10),e.applyMatrix4(o.matrixWorld),this.focusMarker.position.copy(e),this.focusMarker.material.uniforms.realFocusPosition.value.copy(n),this.focusMarker.material.uniforms.viewport.value.copy(i),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){const e=new o.PlaneGeometry(1,1);e.rotateX(-Math.PI/2);const t=new o.MeshBasicMaterial({color:16777215});t.transparent=!0,t.opacity=.6,t.depthTest=!1,t.depthWrite=!1,t.side=o.DoubleSide;const n=new o.Mesh(e,t),i=new o.Vector3(0,1,0);i.normalize();const s=new o.Vector3(0,0,0),r=new E(i,s,.5,.01,56576,.1,.03);this.controlPlane=new o.Object3D,this.controlPlane.add(n),this.controlPlane.add(r)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const e=new o.Quaternion,t=new o.Vector3(0,1,0);return function(n,o){e.setFromUnitVectors(t,o),this.controlPlane.position.copy(n),this.controlPlane.quaternion.copy(e)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.scene.add(this.debugRoot),this.scene.add(this.secondaryDebugRoot)}createDebugMeshes(e){const t=new o.SphereGeometry(1,32,32),n=new o.Object3D,i=(i,s)=>{let r=new o.Mesh(t,B.buildDebugMaterial(i));r.renderOrder=e,n.add(r),r.position.fromArray(s)};return i(16711680,[-50,0,0]),i(16711680,[50,0,0]),i(65280,[0,0,-50]),i(65280,[0,0,50]),i(16755200,[5,0,5]),n}createSecondaryDebugMeshes(e){const t=new o.BoxGeometry(3,3,3),n=new o.Object3D;const i=i=>{let s=new o.Mesh(t,B.buildDebugMaterial(12303291));s.renderOrder=e,n.add(s),s.position.fromArray(i)};let s=10;return i([-10,0,-10]),i([-10,0,s]),i([s,0,-10]),i([s,0,s]),n}static buildDebugMaterial(e){const t={color:{type:"v3",value:new o.Color(e)}},n=new o.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:o.FrontSide});return n.extensions.fragDepth=!0,n}static buildFocusMarkerMaterial(e){const t={color:{type:"v3",value:new o.Color(e)},realFocusPosition:{type:"v3",value:new o.Vector3},viewport:{type:"v2",value:new o.Vector2},opacity:{value:0}};return new o.ShaderMaterial({uniforms:t,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:o.FrontSide})}}const z=new o.Vector3(1,0,0),F=new o.Vector3(0,1,0),V=new o.Vector3(0,0,1);class L{constructor(e=new o.Vector3,t=new o.Vector3){this.origin=new o.Vector3,this.direction=new o.Vector3,this.setParameters(e,t)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const e=new o.Vector3,t=[],n=[],i=[];return function(o,s){if(n[0]=this.origin.x,n[1]=this.origin.y,n[2]=this.origin.z,i[0]=this.direction.x,i[1]=this.direction.y,i[2]=this.direction.z,this.boxContainsPoint(o,this.origin,1e-4))return s&&(s.origin.copy(this.origin),s.normal.set(0,0,0),s.distance=-1),!0;for(let r=0;r<3;r++){if(0==i[r])continue;const a=0==r?z:1==r?F:V,c=i[r]<0?o.max:o.min;let l=-Math.sign(i[r]);t[0]=0==r?c.x:1==r?c.y:c.z;let h=t[0]-n[r];if(h*l<0){const c=(r+1)%3,p=(r+2)%3;if(t[2]=i[c]/i[r]*h+n[c],t[1]=i[p]/i[r]*h+n[p],e.set(t[r],t[p],t[c]),this.boxContainsPoint(o,e,1e-4))return s&&(s.origin.copy(e),s.normal.copy(a).multiplyScalar(l),s.distance=e.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const e=new o.Vector3;return function(t,n,o){e.copy(t).sub(this.origin);const i=e.dot(this.direction),s=i*i,r=e.dot(e)-s,a=n*n;if(r>a)return!1;const c=Math.sqrt(a-r),l=i-c,h=i+c;if(h<0)return!1;let p=l<0?h:l;return o&&(o.origin.copy(this.origin).addScaledVector(this.direction,p),o.normal.copy(o.origin).sub(t).normalize(),o.distance=p),!0}}()}class R{constructor(){this.origin=new o.Vector3,this.normal=new o.Vector3,this.distance=0}set(e,t,n){this.origin.copy(e),this.normal.copy(t),this.distance=n}clone(){const e=new R;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e}}class I{constructor(e,t){this.ray=new L(e,t),this.setFromCameraAndScreenPosition=function(){const e=new o.Vector2;return function(t,n,o){if(e.x=n.x/o.x*2-1,e.y=(o.y-n.y)/o.y*2-1,t.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t;else{if(!t.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(n.x,n.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t}}}(),this.intersectSplatMesh=function(){const e=new o.Matrix4,t=new o.Matrix4,n=new L;return function(o,i=[]){t.copy(o.matrixWorld),e.copy(t).invert(),n.origin.copy(this.ray.origin).applyMatrix4(e),n.direction.copy(this.ray.direction).transformDirection(e);const s=o.getSplatTree();return s.rootNode&&this.castRayAtSplatTreeNode(n,s,s.rootNode,i),i.sort(((e,t)=>e.distance>t.distance?1:-1)),i.forEach((e=>{e.origin.applyMatrix4(t),e.normal.transformDirection(t)})),i}}(),this.castRayAtSplatTreeNode=function(){const e=new o.Vector3,t=new o.Vector3,n=new o.Quaternion,i=new R,s=1e-7;return function(o,r,a,c=[]){if(o.intersectBox(a.boundingBox)){if(a.data.indexes&&a.data.indexes.length>0)for(let l=0;l<a.data.indexes.length;l++){const h=a.data.indexes[l];if(r.splatBuffer.getPosition(h,e),r.splatBuffer.getRotation(h,n),r.splatBuffer.getScale(h,t),t.x<=s||t.y<=s||t.z<=s)continue;const p=(t.x+t.y+t.z)/3;o.intersectSphere(e,p,i)&&c.push(i.clone())}if(a.children&&a.children.length>0)for(let e of a.children)this.castRayAtSplatTreeNode(o,r,e,c);return c}}}()}setFromCameraAndScreenPosition(e,t,n){}intersectSplatMesh(e,t=[]){}castRayAtSplatTreeNode(e,t,n,o=[]){}}let k=0;class U{constructor(e,t,n,i){this.min=(new o.Vector3).copy(e),this.max=(new o.Vector3).copy(t),this.boundingBox=new o.Box3(this.min,this.max),this.center=(new o.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=n,this.children=[],this.data=null,this.id=i||k++}}class O{constructor(e,t){this.maxDepth=e,this.maxPositionsPerNode=t,this.splatBuffer=null,this.sceneDimensions=new o.Vector3,this.sceneMin=new o.Vector3,this.sceneMax=new o.Vector3,this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[]}processSplatBuffer(e,t=(()=>!0)){this.splatBuffer=e,this.addedIndexes={},this.nodesWithIndexes=[];const n=e.getSplatCount(),i=new o.Vector3;for(let o=0;o<n;o++)t(o)&&(e.getPosition(o,i),(0===o||i.x<this.sceneMin.x)&&(this.sceneMin.x=i.x),(0===o||i.x>this.sceneMax.x)&&(this.sceneMax.x=i.x),(0===o||i.y<this.sceneMin.y)&&(this.sceneMin.y=i.y),(0===o||i.y>this.sceneMax.y)&&(this.sceneMax.y=i.y),(0===o||i.z<this.sceneMin.z)&&(this.sceneMin.z=i.z),(0===o||i.z>this.sceneMax.z)&&(this.sceneMax.z=i.z));this.sceneDimensions.copy(this.sceneMin).sub(this.sceneMin);const s=[];for(let e=0;e<n;e++)t(e)&&s.push(e);this.rootNode=new U(this.sceneMin,this.sceneMax,0),this.rootNode.data={indexes:s},this.processNode(this.rootNode,e)}processNode(e,t){const n=e.data.indexes.length;if(n<this.maxPositionsPerNode||e.depth>this.maxDepth){const t=[];for(let n=0;n<e.data.indexes.length;n++)this.addedIndexes[e.data.indexes[n]]||(t.push(e.data.indexes[n]),this.addedIndexes[e.data.indexes[n]]=!0);return e.data.indexes=t,void this.nodesWithIndexes.push(e)}const i=(new o.Vector3).copy(e.max).sub(e.min),s=(new o.Vector3).copy(i).multiplyScalar(.5),r=(new o.Vector3).copy(e.min).add(s),a=[new o.Box3(new o.Vector3(r.x-s.x,r.y,r.z-s.z),new o.Vector3(r.x,r.y+s.y,r.z)),new o.Box3(new o.Vector3(r.x,r.y,r.z-s.z),new o.Vector3(r.x+s.x,r.y+s.y,r.z)),new o.Box3(new o.Vector3(r.x,r.y,r.z),new o.Vector3(r.x+s.x,r.y+s.y,r.z+s.z)),new o.Box3(new o.Vector3(r.x-s.x,r.y,r.z),new o.Vector3(r.x,r.y+s.y,r.z+s.z)),new o.Box3(new o.Vector3(r.x-s.x,r.y-s.y,r.z-s.z),new o.Vector3(r.x,r.y,r.z)),new o.Box3(new o.Vector3(r.x,r.y-s.y,r.z-s.z),new o.Vector3(r.x+s.x,r.y,r.z)),new o.Box3(new o.Vector3(r.x,r.y-s.y,r.z),new o.Vector3(r.x+s.x,r.y,r.z+s.z)),new o.Box3(new o.Vector3(r.x-s.x,r.y-s.y,r.z),new o.Vector3(r.x,r.y,r.z+s.z))],c=[],l=[];for(let e=0;e<a.length;e++)c[e]=0,l[e]=[];const h=new o.Vector3;for(let o=0;o<n;o++){const n=e.data.indexes[o];t.getPosition(n,h);for(let e=0;e<a.length;e++)a[e].containsPoint(h)&&(c[e]++,l[e].push(n))}for(let t=0;t<a.length;t++){const n=new U(a[t].min,a[t].max,e.depth+1);n.data={indexes:l[t]},e.children.push(n)}e.data={};for(let n of e.children)this.processNode(n,t)}countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let o of e.children)t(o,n)};return t(this.rootNode,e)}}class _ extends o.Mesh{static buildMesh(e,t=1,n=!1,o=1){const i=_.buildGeomtery(e),s=_.buildMaterial();return new _(e,i,s,t,n,o)}constructor(e,t,n,o=1,i=!1,s=1){super(t,n),this.splatBuffer=e,this.geometry=t,this.material=n,this.splatTree=null,this.splatDataTextures=null,this.splatAlphaRemovalThreshold=o,this.halfPrecisionCovariancesOnGPU=i,this.devicePixelRatio=s,this.buildSplatTree(),this.resetLocalSplatDataAndTexturesFromSplatBuffer()}static buildMaterial(){const e={covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},focal:{type:"v2",value:new o.Vector2},viewport:{type:"v2",value:new o.Vector2},basisViewport:{type:"v2",value:new o.Vector2},debugColor:{type:"v3",value:new o.Color},covariancesTextureSize:{type:"v2",value:new o.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new o.Vector2(1024,1024)}};return new o.ShaderMaterial({uniforms:e,vertexShader:"\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;\n            uniform vec2 focal;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vPosition = position.xy * 2.0;\n\n                vec4 viewCenter = modelViewMatrix * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n                mat3 W = transpose(mat3(modelViewMatrix));\n                mat3 T = W * J;\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance\n                // matrix (called 'conic') to determine fragment opacity.\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(trace * trace / 4.0 - D);\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value\n\n                const float maxSplatSize = 1024.0;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);\n                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            }",fragmentShader:"\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // compute the negative squared distance from the center of the splat to the\n                // current fragment in the splat's local space.\n                float A = -dot(vPosition, vPosition);\n                if (A < -4.0) discard;\n                vec3 color = vColor.rgb;\n                A = exp(A) * vColor.a;\n                gl_FragColor = vec4(color.rgb, A);\n            }",transparent:!0,alphaTest:1,blending:o.NormalBlending,depthTest:!0,depthWrite:!1,side:o.DoubleSide})}static buildGeomtery(e){const t=e.getSplatCount(),n=new o.BufferGeometry;n.setIndex([0,1,2,0,2,3]);const i=new Float32Array(12),s=new o.BufferAttribute(i,3);n.setAttribute("position",s),s.setXYZ(0,-1,-1,0),s.setXYZ(1,-1,1,0),s.setXYZ(2,1,1,0),s.setXYZ(3,1,-1,0),s.needsUpdate=!0;const r=(new o.InstancedBufferGeometry).copy(n),a=new Uint32Array(t),c=new o.InstancedBufferAttribute(a,1,!1);return c.setUsage(o.DynamicDrawUsage),r.setAttribute("splatIndex",c),r.instanceCount=t,r}buildSplatTree(){this.splatTree=new O(10,500),console.time("SplatTree build");const e=new o.Vector4;this.splatTree.processSplatBuffer(this.splatBuffer,(t=>(this.splatBuffer.getColor(t,e),e.w>this.splatAlphaRemovalThreshold))),console.timeEnd("SplatTree build");let t=0,n=0,i=0,s=0;this.splatTree.visitLeaves((e=>{const o=e.data.indexes.length;o>0&&(n+=o,i=Math.max(i,o),s++,t++)})),console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${t}`),n/=s,console.log(`Avg splat count per node: ${n}`)}getSplatTree(){return this.splatTree}resetLocalSplatDataAndTexturesFromSplatBuffer(){this.updateLocalSplatDataFromSplatBuffer(),this.allocateAndStoreLocalSplatDataInTextures()}updateLocalSplatDataFromSplatBuffer(){const e=this.splatBuffer.getSplatCount();this.covariances=new Float32Array(6*e),this.colors=new Uint8Array(4*e),this.centers=new Float32Array(3*e),this.splatBuffer.fillCovarianceArray(this.covariances),this.splatBuffer.fillPositionArray(this.centers),this.splatBuffer.fillColorArray(this.colors)}allocateAndStoreLocalSplatDataInTextures(){const e=this.splatBuffer.getSplatCount(),t=new o.Vector2(4096,1024);for(;t.x*t.y*2<6*e;)t.y*=2;const n=new o.Vector2(4096,1024);for(;n.x*n.y*4<4*e;)n.y*=2;let i,s;if(this.halfPrecisionCovariancesOnGPU){s=new Uint16Array(t.x*t.y*2);for(let e=0;e<this.covariances.length;e++)s[e]=o.DataUtils.toHalfFloat(this.covariances[e]);i=new o.DataTexture(s,t.x,t.y,o.RGFormat,o.HalfFloatType)}else s=new Float32Array(t.x*t.y*2),s.set(this.covariances),i=new o.DataTexture(s,t.x,t.y,o.RGFormat,o.FloatType);i.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=i,this.material.uniforms.covariancesTextureSize.value.copy(t);const r=new Uint32Array(n.x*n.y*4);for(let t=0;t<e;t++){const e=4*t,n=3*t,o=4*t;r[o]=(a=this.colors[e],c=this.colors[e+1],l=this.colors[e+2],h=this.colors[e+3],a+(c<<8)+(l<<16)+(h<<24)),r[o+1]=d(this.centers[n]),r[o+2]=d(this.centers[n+1]),r[o+3]=d(this.centers[n+2])}var a,c,l,h;const p=new o.DataTexture(r,n.x,n.y,o.RGBAIntegerFormat,o.UnsignedIntType);p.internalFormat="RGBA32UI",p.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=p,this.material.uniforms.centersColorsTextureSize.value.copy(n),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={covariances:{data:s,texture:i,size:t},centerColors:{data:r,texture:p,size:n}}}updateSplatDataToDataTextures(){this.updateLocalCovarianceDataToDataTexture(),this.updateLocalCenterColorDataToDataTexture()}updateLocalCovarianceDataToDataTexture(){this.splatDataTextures.covariances.data.set(this.covariances),this.splatDataTextures.covariances.texture.needsUpdate=!0}updateLocalCenterColorDataToDataTexture(){this.splatDataTextures.centerColors.data.set(this.centerColors),this.splatDataTextures.centerColors.texture.needsUpdate=!0}updateIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,n.instanceCount=t}updateUniforms=function(){const e=new o.Vector2;return function(t,n,o){this.splatBuffer.getSplatCount()>0&&(e.set(t.x*this.devicePixelRatio,t.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(e),this.material.uniforms.basisViewport.value.set(2/e.x,2/e.y),this.material.uniforms.focal.value.set(n,o),this.material.uniformsNeedUpdate=!0)}}();getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return this.splatBuffer.getSplatCount()}getCenters(){return this.centers}getColors(){return this.colors}getCovariances(){return this.covariances}}class N{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4}function j(e){let t,n,o,i,s,r,a,c,l,h,p;e.onmessage=u=>{if(u.data.positions){l=u.data.positions;const t=new Float32Array(l),o=new Int32Array(3*n);for(let e=0;e<3*n;e++)o[e]=Math.round(1e3*t[e]);new Int32Array(c,i,3*n).set(o),e.postMessage({sortSetupComplete:!0})}else if(u.data.sort){const l=u.data.sort.splatRenderCount||0;!function(l,u,d,m){const y=performance.now();h||(h=new Uint32Array(p.DepthMapRange));const f=new Int32Array(c,s,16);for(let e=0;e<16;e++)f[e]=Math.round(1e3*d[e]);new Uint32Array(c,a+4*n,p.DepthMapRange).set(h),t.exports.sortIndexes(o,i,a,s,r,m[0],m[1],m[2],p.DepthMapRange,l,u,n);const g=performance.now();e.postMessage({sortDone:!0,splatSortCount:l,splatRenderCount:u,sortTime:g-y})}(u.data.sort.splatSortCount||0,l,u.data.sort.view,u.data.sort.cameraPosition,u.data.sort.inIndexBuffer)}else if(u.data.init){p=u.data.init.Constants,n=u.data.init.splatCount;const l=p.BytesPerInt,h=3*p.BytesPerFloat,d=new Uint8Array(u.data.init.sorterWasmBytes),m=n*(l+h)+(n*p.BytesPerInt*2+p.DepthMapRange*p.BytesPerInt*2)+32*p.MemoryPageSize,y=Math.floor(m/p.MemoryPageSize)+1,f={module:{},env:{memory:new WebAssembly.Memory({initial:2*y,maximum:3*y,shared:!0})}};WebAssembly.compile(d).then((e=>WebAssembly.instantiate(e,f))).then((u=>{t=u,o=0,i=n*l,s=i+n*h,a=s+16*p.BytesPerFloat,r=a+n*p.BytesPerInt+p.DepthMapRange*p.BytesPerInt*2,c=f.env.memory.buffer,e.postMessage({sortSetupPhase1Complete:!0,inIndexBuffer:c,inIndexOffset:0,outIndexBuffer:c,outIndexOffset:r})}))}}}e.PlyLoader=C,e.PlyParser=w,e.SplatBuffer=u,e.SplatLoader=v,e.Viewer=class{requestAnimationFrameID=void 0;constructor(e={}){e.cameraUp||(e.cameraUp=[0,1,0]),e.initialCameraPosition||(e.initialCameraPosition=[0,10,15]),e.initialCameraLookAt||(e.initialCameraLookAt=[0,0,0]),void 0===e.selfDrivenMode&&(e.selfDrivenMode=!0),void 0===e.useBuiltInControls&&(e.useBuiltInControls=!0),this.rootElement=e.rootElement,this.usingExternalCamera=!!e.camera,this.usingExternalRenderer=!!e.renderer,this.cameraUp=(new o.Vector3).fromArray(e.cameraUp),this.initialCameraPosition=(new o.Vector3).fromArray(e.initialCameraPosition),this.initialCameraLookAt=(new o.Vector3).fromArray(e.initialCameraLookAt),this.scene=e.scene,this.renderer=e.renderer,this.camera=e.camera,this.useBuiltInControls=e.useBuiltInControls,this.controls=null,this.ignoreDevicePixelRatio=e.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,this.selfDrivenMode=e.selfDrivenMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.splatRenderCount=0,this.splatSortCount=0,this.inIndexArray=null,this.splatMesh=null,this.sortRunning=!1,this.selfDrivenModeRunning=!1,this.splatRenderingInitialized=!1,this.raycaster=new I,this.infoPanel=null,this.infoPanelCells={},this.currentFPS=0,this.lastSortTime=0,this.previousCameraTarget=new o.Vector3,this.nextCameraTarget=new o.Vector3,this.mousePosition=new o.Vector2,this.mouseDownPosition=new o.Vector2,this.mouseDownTime=null,this.initialized=!1,this.init(),this.onKeyDown=(()=>{const e=new o.Vector3,t=new o.Matrix4,n=new o.Matrix4;return function(o){switch(e.set(0,0,-1),e.transformDirection(this.camera.matrixWorld),t.makeRotationAxis(e,Math.PI/128),n.makeRotationAxis(e,-Math.PI/128),o.code){case"ArrowLeft":this.camera.up.transformDirection(t);break;case"ArrowRight":this.camera.up.transformDirection(n);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyP":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.style.display="block":this.infoPanel.style.display="none"}}})(),this.onMouseUp=(()=>{const e=new o.Vector2,t=new o.Vector2,n=new o.Vector3,i=[];return function(o){t.copy(this.mousePosition).sub(this.mouseDownPosition);const s=f()-this.mouseDownTime<.5&&t.length()<2;if(!this.transitioningCameraTarget&&s&&(this.getRenderDimensions(e),i.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,e),this.mousePosition.set(o.offsetX,o.offsetY),this.raycaster.intersectSplatMesh(this.splatMesh,i),i.length>0)){const e=i[0].origin;n.copy(e).sub(this.camera.position),n.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=f())}}})(),this.updateSplatMeshUniforms=(()=>{const e=new o.Vector2;return function(){this.splatMesh.getSplatCount()>0&&(this.getRenderDimensions(e),this.cameraFocalLengthX=this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*e.x*.45,this.cameraFocalLengthY=this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*e.y*.45,this.splatMesh.updateUniforms(e,this.cameraFocalLengthX,this.cameraFocalLengthY))}})(),this.gatherSceneNodes=(()=>{const e=[],t=new o.Vector3,n=new o.Vector3,i=new o.Vector3,s=new o.Matrix4,r=new o.Vector3,a=new o.Vector3(0,0,-1),c=new o.Vector3,l=e=>c.copy(e.max).sub(e.min).length();return function(c){this.getRenderDimensions(r);const h=r.y/2/Math.tan(this.camera.fov/2*o.MathUtils.DEG2RAD),p=Math.atan(r.x/2/h),u=Math.atan(r.y/2/h),d=Math.cos(p),m=Math.cos(u);s.copy(this.camera.matrixWorld).invert(),s.multiply(this.splatMesh.matrixWorld);const y=this.splatMesh.getSplatTree();let f=0,g=0;const w=y.nodesWithIndexes.length;for(let o=0;o<w;o++){const r=y.nodesWithIndexes[o];i.copy(r.center).applyMatrix4(s);const h=i.length();i.normalize(),t.copy(i).setX(0).normalize(),n.copy(i).setY(0).normalize();const p=a.dot(n),u=a.dot(t),w=l(r);!c&&(p<d-.5||u<m-.5||h>125)&&h>w||(g+=r.data.indexes.length,e[f]=r,r.data.distanceToNode=h,f++)}e.length=f,e.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?1:-1)),this.splatRenderCount=g,this.splatSortCount=0;let C=g*N.BytesPerInt;for(let t=0;t<f;t++){const n=e[t];n.data.distanceToNode<=125&&(this.splatSortCount+=n.data.indexes.length);const o=n.data.indexes.length,i=o*N.BytesPerInt;new Uint32Array(this.inIndexArray.buffer,C-i,o).set(n.data.indexes),C-=i}}})(),this.updateFPS=(()=>{let e=f(),t=0;return function(){const n=f();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}})(),this.timingSensitiveUpdates=(()=>{let e;return function(){const t=f();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}})(),this.updateCameraTransition=(()=>{let e=new o.Vector3,t=new o.Vector3,n=new o.Vector3;return function(o){if(this.transitioningCameraTarget){t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const i=Math.acos(t.dot(n)),s=(i/(Math.PI/3)*.65+.3)/i*(o-this.transitioningCameraTargetStartTime);e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,s),this.camera.lookAt(e),this.controls.target.copy(e),s>=1&&(this.transitioningCameraTarget=!1)}}})(),this.updateMeshCursor=(()=>{const e=[],t=new o.Vector2;return function(){this.showMeshCursor?(this.getRenderDimensions(t),e.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,e),e.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(e[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):this.sceneHelper.setMeshCursorVisibility(!1)}})(),this.updateForRendererSizeChanges=(()=>{const e=new o.Vector2,t=new o.Vector2;return function(){this.renderer.getSize(t),t.x===e.x&&t.y===e.y||(this.usingExternalCamera||(this.camera.aspect=t.x/t.y,this.camera.updateProjectionMatrix()),this.splatRenderingInitialized&&this.updateSplatMeshUniforms(),e.copy(t))}})(),this.updateInfo=(()=>{const e=new o.Vector2;return function(){if(this.showInfo){const t=this.splatMesh.getSplatCount();this.getRenderDimensions(e);const n=this.camera.position,o=`[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;this.infoPanelCells.cameraPosition.innerHTML=o;const i=this.controls.target,s=`[${i.x.toFixed(5)}, ${i.y.toFixed(5)}, ${i.z.toFixed(5)}]`;this.infoPanelCells.cameraLookAt.innerHTML=s;const r=this.camera.up,a=`[${r.x.toFixed(5)}, ${r.y.toFixed(5)}, ${r.z.toFixed(5)}]`;if(this.infoPanelCells.cameraUp.innerHTML=a,this.showMeshCursor){const e=this.sceneHelper.meshCursor.position,t=`[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;this.infoPanelCells.cursorPosition.innerHTML=t}else this.infoPanelCells.cursorPosition.innerHTML="N/A";this.infoPanelCells.fps.innerHTML=this.currentFPS,this.infoPanelCells.renderWindow.innerHTML=`${e.x} x ${e.y}`;const c=this.splatRenderCount/t*100;this.infoPanelCells.renderSplatCount.innerHTML=`${this.splatRenderCount} splats out of ${t} (${c.toFixed(2)}%)`,this.infoPanelCells.sortTime.innerHTML=`${this.lastSortTime.toFixed(3)} ms`}}})(),this.updateFocusMarker=(()=>{const e=new o.Vector2;let t=!1;return function(n){this.getRenderDimensions(e);if(this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const o=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let i=Math.min(o+10*n,1);this.sceneHelper.setFocusMarkerOpacity(i),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e),t=!0}else{let o;if(o=t?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),o>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,e);let t=Math.max(o-2.5*n,0);this.sceneHelper.setFocusMarkerOpacity(t),0===t&&this.sceneHelper.setFocusMarkerVisibility(!1)}t=!1}}})(),this.render=function(){const e=this.renderer.autoClear;this.renderer.autoClear=!1,(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.scene)&&this.renderer.render(this.scene,this.camera),this.renderer.render(this.splatMesh,this.camera),this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e},this.updateView=function(){const e=new o.Matrix4,t=[],n=new o.Vector3(0,0,-1),i=new o.Vector3(0,0,-1),s=new o.Vector3,r=new o.Vector3;return function(o=!1,a=!1){if(!o){i.set(0,0,-1).applyQuaternion(this.camera.quaternion);let e=!1,t=!1;if(i.dot(n)<=.95&&(e=!0),r.copy(this.camera.position).sub(s).length()>=1&&(t=!0),!e&&!t)return}e.copy(this.camera.matrixWorld).invert(),e.premultiply(this.camera.projectionMatrix),e.multiply(this.splatMesh.matrixWorld),t[0]=this.camera.position.x,t[1]=this.camera.position.y,t[2]=this.camera.position.z,this.sortRunning||(this.gatherSceneNodes(a),this.sortRunning=!0,this.sortWorker.postMessage({sort:{view:e.elements,cameraPosition:t,splatRenderCount:this.splatRenderCount,splatSortCount:this.splatSortCount,inIndexBuffer:this.inIndexArray.buffer}}),s.copy(this.camera.position),n.copy(i))}}()}init(){if(this.initialized)return;this.rootElement||this.usingExternalRenderer||(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",document.body.appendChild(this.rootElement));const e=new o.Vector2;if(this.getRenderDimensions(e),this.usingExternalCamera||(this.camera=new o.PerspectiveCamera(50,e.x/e.y,.1,500),this.camera.position.copy(this.initialCameraPosition),this.camera.lookAt(this.initialCameraLookAt),this.camera.up.copy(this.cameraUp).normalize()),this.usingExternalRenderer||(this.renderer=new o.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(0,0,0,0),this.renderer.setSize(e.x,e.y)),this.scene=this.scene||new o.Scene,this.sceneHelper=new B(this.scene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.useBuiltInControls&&(this.controls=new D(this.camera,this.renderer.domElement),this.controls.listenToKeyEvents(window),this.controls.rotateSpeed=.5,this.controls.maxPolarAngle=.75*Math.PI,this.controls.minPolarAngle=.1,this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.target.copy(this.initialCameraLookAt),this.rootElement.addEventListener("pointermove",this.onMouseMove.bind(this),!1),this.rootElement.addEventListener("pointerdown",this.onMouseDown.bind(this),!1),this.rootElement.addEventListener("pointerup",this.onMouseUp.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1)),!this.usingExternalRenderer){new ResizeObserver((()=>{this.getRenderDimensions(e),this.renderer.setSize(e.x,e.y)})).observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}this.setupInfoPanel(),this.loadingSpinner=new T(null,this.rootElement),this.loadingSpinner.hide(),this.initialized=!0}onKeyDown(e){}onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=f()}onMouseUp(e){}getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setupInfoPanel(){this.infoPanel=document.createElement("div"),this.infoPanel.style.position="absolute",this.infoPanel.style.padding="10px",this.infoPanel.style.backgroundColor="#cccccc",this.infoPanel.style.border="#aaaaaa 1px solid",this.infoPanel.style.zIndex=100,this.infoPanel.style.width="375px",this.infoPanel.style.fontFamily="arial",this.infoPanel.style.fontSize="10pt",this.infoPanel.style.textAlign="left";const e=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Cursor position","cursorPosition"],["FPS","fps"],["Render window","renderWindow"],["Rendering:","renderSplatCount"],["Sort time","sortTime"]],t=document.createElement("div");t.style.display="table";for(let n of e){const e=document.createElement("div");e.style.display="table-row";const o=document.createElement("div");o.style.display="table-cell",o.style.width="110px",o.innerHTML=`${n[0]}: `;const i=document.createElement("div");i.style.display="table-cell",i.style.width="10px",i.innerHTML=" ";const s=document.createElement("div");s.style.display="table-cell",s.innerHTML="",this.infoPanelCells[n[1]]=s,e.appendChild(o),e.appendChild(i),e.appendChild(s),t.appendChild(e)}this.infoPanel.appendChild(t),this.infoPanel.style.display="none",this.renderer.domElement.parentElement.prepend(this.infoPanel)}updateSplatMeshUniforms(){}loadFile(e,t={}){t.position&&(t.position=(new o.Vector3).fromArray(t.position)),t.orientation&&(t.orientation=(new o.Quaternion).fromArray(t.orientation)),t.splatAlphaRemovalThreshold=t.splatAlphaRemovalThreshold||1,t.halfPrecisionCovariancesOnGPU=!!t.halfPrecisionCovariancesOnGPU,!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),t.showLoadingSpinner&&this.loadingSpinner.show();const n=(e,n)=>{if(t.showLoadingSpinner)if(100==e)this.loadingSpinner.setMessage("Download complete!");else{const e=n?`: ${n}`:"...";this.loadingSpinner.setMessage(`Downloading${e}`)}t.onProgress&&t.onProgress(e,n,"downloading")};return new Promise(((o,i)=>{let s;e.endsWith(".splat")?s=(new v).loadFromURL(e,n):e.endsWith(".ply")?s=(new C).loadFromURL(e,n):i(new Error(`Viewer::loadFile -> File format not supported: ${e}`)),s.then((e=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),t.onProgress&&t.onProgress(0,"0%","processing"),this.loadSplatBuffer(e,t).then((()=>{t.onProgress&&t.onProgress(100,"100%","processing"),o()}))})).catch((t=>{i(new Error(`Viewer::loadFile -> Could not load file ${e}`))}))}))}loadSplatBuffer(e,t){return!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),new Promise((n=>{t.showLoadingSpinner&&(this.loadingSpinner.show(),this.loadingSpinner.setMessage("Processing splats...")),window.setTimeout((()=>{this.setupSplatMesh(e,t.splatAlphaRemovalThreshold,t.position,t.orientation,t.halfPrecisionCovariancesOnGPU,this.devicePixelRatio),this.setupSortWorker(e).then((()=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),n()}))}),1)}))}setupSplatMesh(e,t=1,n=new o.Vector3,i=new o.Quaternion,s=!1,r=1){const a=e.getSplatCount();console.log(`Splat count: ${a}`),this.splatMesh=_.buildMesh(e,t,s,r),this.splatMesh.position.copy(n),this.splatMesh.quaternion.copy(i),this.splatMesh.frustumCulled=!1,this.updateSplatMeshUniforms(),this.splatRenderCount=a}setupSortWorker(e){return new Promise((t=>{const n=e.getSplatCount();this.sortWorker=function(e){const t=new Worker(URL.createObjectURL(new Blob(["(",j.toString(),")(self)"],{type:"application/javascript"}))),n=atob("AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAMf39/f399fX1/f39/AGAAAX8CEgEDZW52Bm1lbW9yeQIDAICABAMEAwABAgc5AxFfX3dhc21fY2FsbF9jdG9ycwAAC3NvcnRJbmRleGVzAAETZW1zY3JpcHRlbl90bHNfaW5pdAACCqAEAwMAAQuUBAEFfwJAIAogCWsiDiAKSSIQBEBB+P///wchDEGIgICAeCEPIA4hDQNAIAIgDUECdCIJaiABIAAgCWooAgBBDGxqIgkoAgQgAygCGGwgCSgCACADKAIIbGogCSgCCCADKAIobGoiCTYCACAJIAwgCSAMSBshDCAJIA8gCSAPShshDyANQQFqIg0gCkcNAAsgAiALQQJ0aiENIAizIA+yIAyyk5UhBSAQRQ0BIA4hCQNAIA0CfyAFIAIgCUECdGooAgAgDGuylCIGi0MAAABPXQRAIAaoDAELQYCAgIB4C0ECdGoiASABKAIAQQFqNgIAIAlBAWoiCSAKRw0ACwwBCyACIAtBAnRqIQ0gCLNDAACAr5QhBUH4////ByEMCyAIQQJPBEAgDSgCACEDQQEhCQNAIAIgCSALakECdGoiASABKAIAIANqIgM2AgAgCUEBaiIJIAhHDQALCyAOQQBKBEAgDiEJA0AgBCAJQQFrIgFBAnQiA2ogACADaigCADYCACAJQQFKIQMgASEJIAMNAAsLIA4gCkEBayIBTARAIAEhCQNAIAQgASACAn8gBSACIAlBAnQiA2ooAgAgDGuylCIGi0MAAABPXQRAIAaoDAELQYCAgIB4CyALakECdGoiCCgCAEEBayIKa0ECdGogACADaigCADYCACAIIAo2AgAgCSAOSiEDIAlBAWshCSADDQALCwsEAEEACw=="),o=new Uint8Array(n.length);for(let e=0;e<n.length;e++)o[e]=n.charCodeAt(e);return t.postMessage({init:{sorterWasmBytes:o.buffer,splatCount:e,Constants:{BytesPerFloat:N.BytesPerFloat,BytesPerInt:N.BytesPerInt,DepthMapRange:N.DepthMapRange,MemoryPageSize:N.MemoryPageSize}}}),t}(n),this.sortWorker.onmessage=o=>{if(o.data.sortDone)this.sortRunning=!1,this.splatMesh.updateIndexes(this.outIndexArray,o.data.splatRenderCount),this.lastSortTime=o.data.sortTime;else if(o.data.sortCanceled)this.sortRunning=!1;else if(o.data.sortSetupPhase1Complete){console.log("Sorting web worker WASM setup complete."),this.sortWorker.postMessage({positions:this.splatMesh.getCenters().buffer}),this.outIndexArray=new Uint32Array(o.data.outIndexBuffer,o.data.outIndexOffset,e.getSplatCount()),this.inIndexArray=new Uint32Array(o.data.inIndexBuffer,o.data.inIndexOffset,e.getSplatCount());for(let e=0;e<n;e++)this.inIndexArray[e]=e}else if(o.data.sortSetupComplete){console.log("Sorting web worker ready."),this.splatMesh.updateIndexes(this.outIndexArray,e.getSplatCount());const n=this.splatMesh.getSplatDataTextures(),o=n.covariances.size,i=n.centerColors.size;console.log("Covariances texture size: "+o.x+" x "+o.y),console.log("Centers/colors texture size: "+i.x+" x "+i.y),this.updateView(!0,!0),this.splatRenderingInitialized=!0,t()}}}))}gatherSceneNodes(e){}start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");this.requestAnimationFrameID=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(cancelAnimationFrame(this.requestAnimationFrameID),this.selfDrivenModeRunning=!1)}updateFPS(){}updateForRendererSizeChanges(){}selfDrivenUpdate(){this.selfDrivenMode&&(this.requestAnimationFrameID=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.render()}update(){this.controls&&this.controls.update(),this.updateView(),this.updateForRendererSizeChanges(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfo(),this.updateControlPlane()}timingSensitiveUpdates(){}updateCameraTransition(e){}updateFocusMarker(e){}updateMeshCursor(){}updateInfo(){}updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}render(){}updateView(e=!1,t=!1){}getSplatMesh(){return this.splatMesh}}}));
//# sourceMappingURL=gaussian-splats-3d.umd.min.cjs.map
